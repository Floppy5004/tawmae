<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVENT LIST - v.1.1.0 - tawmae.xyz</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
    <style>
        :root {
            --event-size: 26px;
            --bg: radial-gradient(circle at top left, #233449 0%, #101722 45%, #05060a 100%);
            --card-bg: linear-gradient(135deg, rgba(37, 44, 61, 0.92), rgba(15, 19, 30, 0.96));
            --card-border: rgba(255, 255, 255, 0.08);
            --card-shadow: 0 14px 40px rgba(0, 0, 0, 0.65);
        }

        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            zoom: 120%;
        }

        body {
            font-family: 'Poppins', Arial, sans-serif;
            color: #f5f7ff;
            overflow: hidden;
        }

        .event-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 700px;
            max-width: min(700px, 100vw - 40px);
            display: flex;
            flex-direction: column-reverse;
            gap: 10px;
            pointer-events: none;
        }

        .event {
            display: flex;
            align-items: center;
            background: var(--card-bg);
            border-radius: 14px;
            padding: 12px 16px;
            color: #fff;
            opacity: 0;
            transform: translateY(24px) scale(0.98);
            transition: transform 0.6s ease, opacity 0.6s ease, box-shadow 0.4s ease, background 0.4s ease, border-color 0.4s ease;
            animation: slideIn 0.6s forwards;
            border: 1px solid var(--card-border);
            box-shadow: var(--card-shadow);
            backdrop-filter: blur(18px);
            -webkit-backdrop-filter: blur(18px);
            pointer-events: auto;
        }

        .event:hover {
            transform: translateY(0) scale(1.01);
            box-shadow: 0 18px 48px rgba(0, 0, 0, 0.8);
            border-color: rgba(144, 202, 249, 0.4);
            background: linear-gradient(135deg, rgba(45, 60, 88, 0.98), rgba(14, 19, 32, 0.98));
        }

        .event .avatar-wrapper {
            position: relative;
            margin-right: 14px;
            flex-shrink: 0;
        }

        .event .avatar {
            width: calc(var(--event-size) * 2.4);
            height: calc(var(--event-size) * 2.4);
            border-radius: 12px;
            background-size: cover;
            background-position: center;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.7);
        }

        .event .avatar-ring {
            position: absolute;
            inset: -4px;
            border-radius: 14px;
            border: 2px solid rgba(95, 168, 255, 0.7);
            opacity: 0.35;
            pointer-events: none;
        }

        .event .content {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-width: 0;
            gap: 12px;
        }

        .event .text-block {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .event .content .username {
            font-weight: 700;
            font-size: 26px;
            color: #5fa8ff;
            margin: 0 0 2px;
            letter-spacing: 0.02em;
            text-shadow: 0 0 6px rgba(1, 1, 1, 1);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 260px;
        }

        .event .content .subline {
            font-size: 12px;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: rgba(199, 210, 255, 0.6);
        }

        .event .content .event-info {
            font-size: 22px;
            font-weight: 600;
            color: #b8b8b8;
            text-align: right;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 6px;
            white-space: nowrap;
        }

        .event-info .icon {
            width: 24px;
            height: 24px;
            margin-right: 2px;
            vertical-align: middle;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .event-info .icon svg {
            fill: currentColor;
            width: 100%;
            height: 100%;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(24px) scale(0.94);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes slideOut {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            to {
                opacity: 0;
                transform: translateY(-20px) scale(0.9);
            }
        }

        @media (max-width: 640px) {
            .event-container {
                right: 12px;
                left: 12px;
                width: auto;
            }

            .event {
                padding: 10px 12px;
            }

            .event .content .username {
                font-size: 18px;
            }

            .event .content .event-info {
                font-size: 16px;
            }
        }
    </style>
</head>

<body>
    <div id="eventContainer" class="event-container"></div>
    <script>
        const eventContainer = document.getElementById('eventContainer');
        const maxVisibleEvents = 4;
        const eventQueue = [];
        let isProcessingQueue = false;
        const avatarCache = new Map();

        function getURLParams() {
            const params = new URLSearchParams(window.location.search);
            const normalizedParams = {};
            for (const [key, value] of params.entries()) {
                normalizedParams[key.toLowerCase()] = value;
            }
            return {
                font: normalizedParams['font'] || 'Poppins',
                color: normalizedParams['color'] || 'linear-gradient(135deg, rgba(37, 44, 61, 0.92), rgba(15, 19, 30, 0.96))',
                usernameColor: normalizedParams['usernamecolor'] || '#5fa8ff',
                eventColor: normalizedParams['eventcolor'] || '#e5e7f5',
                usernameSize: normalizedParams['usernamesize'] || '28px',
                eventSize: normalizedParams['eventsize'] || '22px',
                width: normalizedParams['width'] || '640px',
                anonymousFollows: normalizedParams['anonymousfollows'] === 'true',
                watchstreaks: normalizedParams['watchstreaks'],
                address: normalizedParams['address'] || 'localhost',
                port: normalizedParams['port'] || '8080'
            };
        }

        const urlParams = getURLParams();

        function applyDynamicStyles() {
            const dynamicStyle = document.createElement('style');
            dynamicStyle.textContent = `
                :root {
                    --event-size: ${urlParams.eventSize};
                }
                body {
                    font-family: ${urlParams.font}, Arial, sans-serif;
                }
                .event-container {
                    width: ${urlParams.width};
                }
                .event {
                    background: ${urlParams.color};
                }
                .event .content .username {
                    color: ${urlParams.usernameColor};
                    font-size: ${urlParams.usernameSize};
                }
                .event .content .event-info {
                    color: ${urlParams.eventColor};
                    font-size: ${urlParams.eventSize};
                }
                .event-info .icon {
                    width: calc(${urlParams.eventSize} * 0.9);
                    height: calc(${urlParams.eventSize} * 0.9);
                }
            `;
            document.head.appendChild(dynamicStyle);
        }

        function getStoredEvents() {
            const storedEvents = localStorage.getItem('eventListStoredEvents');
            return storedEvents ? JSON.parse(storedEvents) : [];
        }

        function saveEventToStorage(username, eventInfo, avatarUrl, subline) {
            const storedEvents = getStoredEvents();
            storedEvents.push({ username, eventInfo, avatarUrl, subline });
            if (storedEvents.length > maxVisibleEvents) storedEvents.shift();
            localStorage.setItem('eventListStoredEvents', JSON.stringify(storedEvents));
        }

        function clearEvents() {
            localStorage.removeItem('eventListStoredEvents');
            eventContainer.innerHTML = '';
        }

        function loadStoredEvents() {
            const storedEvents = getStoredEvents();
            storedEvents.forEach(event => {
                addEventNotification(event.username, event.eventInfo, event.avatarUrl, event.subline, false);
            });
        }

        async function fetchIcon(iconName) {
            try {
                const response = await fetch(`https://api.iconify.design/${iconName}.svg`);
                if (response.ok) {
                    return await response.text();
                }
                return '';
            } catch {
                return '';
            }
        }

        async function fetchAvatar(username) {
            const key = username.toLowerCase();
            if (avatarCache.has(key)) return avatarCache.get(key);
            try {
                const response = await fetch(`https://decapi.me/twitch/avatar/${key}`);
                if (response.ok) {
                    const url = await response.text();
                    avatarCache.set(key, url);
                    return url;
                }
            } catch { }
            const fallback = 'https://static-cdn.jtvnw.net/user-default-pictures-uv/13e5fa74-defa-11e9-809c-784f43822e80-profile_image-300x300.png';
            avatarCache.set(key, fallback);
            return fallback;
        }

        function getIconName(eventInfo) {
            if (eventInfo.includes('FOLLOW')) return 'material-symbols-light:favorite';
            if (eventInfo.includes('CHEER')) return 'mingcute:diamond-square-fill';
            if (eventInfo.includes('SUB')) return 'material-symbols:star';
            if (eventInfo.includes('GIFTSUB')) return 'material-symbols:star';
            if (eventInfo.includes('GIFTBOMB')) return 'material-symbols:star';
            if (eventInfo.includes('RAID')) return 'ion:people-sharp';
            if (eventInfo.includes('KOFI')) return 'material-symbols-light:money-bag-rounded';
            if (eventInfo.includes('WATCHSTREAK')) return 'icon-park-outline:fire';
            return 'typcn:arrow-unsorted';
        }

        async function addEventNotification(username, eventInfo, avatarUrl, sublineText, saveToStorage = true) {
            return new Promise(async (resolve) => {
                const eventElement = document.createElement('div');
                eventElement.className = 'event';

                const iconName = getIconName(eventInfo);
                const iconSvg = await fetchIcon(iconName);

                eventElement.innerHTML = `
                    <div class="avatar-wrapper">
                        <div class="avatar" style="background-image: url('${avatarUrl}');"></div>
                        <div class="avatar-ring"></div>
                    </div>
                    <div class="content">
                        <div class="text-block">
                            <p class="username">${username}</p>
                            <span class="subline">${sublineText || ''}</span>
                        </div>
                        <p class="event-info">
                            ${iconSvg ? `<span class="icon">${iconSvg}</span>` : ''}<span>${eventInfo}</span>
                        </p>
                    </div>
                `;

                eventContainer.prepend(eventElement);

                if (saveToStorage) saveEventToStorage(username, eventInfo, avatarUrl, sublineText);

                if (eventContainer.childNodes.length > maxVisibleEvents) {
                    const lastEvent = eventContainer.lastChild;
                    lastEvent.style.animation = 'slideOut 0.5s forwards';
                    setTimeout(() => {
                        lastEvent.remove();
                        resolve();
                    }, 500);
                } else {
                    setTimeout(resolve, 500);
                }
            });
        }

        async function buildEventFromPayload(payload) {
            if (!payload || !payload.type || !payload.data) return null;
            let avatarUrl = '';
            let username = '';
            let eventInfo = '';
            let sublineText = '';

            switch (payload.type) {
                case 'Follow': {
                    if (urlParams.anonymousFollows) {
                        username = 'SOMEONE';
                        avatarUrl = 'https://raw.githubusercontent.com/tawmae/tawmae.github.io/refs/heads/main/assets/media/heart-png.png';
                    } else {
                        username = payload.data.user_name;
                        avatarUrl = await fetchAvatar(payload.data.user_login);
                    }
                    eventInfo = 'FOLLOW';
                    sublineText = 'joined us <3';
                    break;
                }
                case 'Cheer': {
                    username = payload.data.message.displayName;
                    avatarUrl = await fetchAvatar(payload.data.message.username);
                    eventInfo = `CHEER (${payload.data.bits})`;
                    sublineText = 'cheered some bits';
                    break;
                }
                case 'Sub': {
                    username = payload.data.user.name;
                    avatarUrl = await fetchAvatar(payload.data.user.login);
                    const tier = payload.data.sub_tier ? payload.data.sub_tier / 1000 : 1;
                    eventInfo = payload.data.is_prime ? 'SUB (PRIME)' : `SUB (T${tier})`;
                    sublineText = 'just subscribed';
                    break;
                }
                case 'ReSub:Legacy': {
                    username = payload.data.user.name;
                    avatarUrl = await fetchAvatar(payload.data.user.login);
                    const tier = payload.data.subTier ? parseInt(payload.data.subTier, 10) / 1000 : 1;
                    eventInfo = payload.data.isPrime
                        ? `RESUB X${payload.data.cumulativeMonths} (PRIME)`
                        : `RESUB X${payload.data.cumulativeMonths} (T${tier})`;
                    sublineText = 'renewed their sub';
                    break;
                }
                case 'ReSub': {
                    username = payload.data.user_name;
                    avatarUrl = await fetchAvatar(payload.data.user_login);
                    const tier = payload.data.tier ? parseInt(payload.data.tier, 10) / 1000 : 1;
                    eventInfo = `RESUB X${payload.data.total_months} (T${tier})`;
                    sublineText = 'renewed their sub';
                    break;
                }
                case 'GiftSub': {
                    username = payload.data.user.name;
                    avatarUrl = await fetchAvatar(payload.data.user.login);
                    const tier = payload.data.subTier ? parseInt(payload.data.subTier, 10) / 1000 : 1;
                    eventInfo = `GIFTSUB (T${tier})`;
                    sublineText = 'gifted a sub';
                    break;
                }
                case 'GiftBomb': {
                    username = payload.data.user.name;
                    avatarUrl = await fetchAvatar(payload.data.user.login);
                    const t = payload.data.sub_tier ? parseInt(payload.data.sub_tier, 10) / 1000 : 1;
                    eventInfo = `GIFTBOMB (${payload.data.total} T${t})`;
                    sublineText = 'dropped a bomb';
                    break;
                }
                case 'Raid': {
                    username = payload.data.from_broadcaster_user_name;
                    avatarUrl = await fetchAvatar(payload.data.from_broadcaster_user_login);
                    eventInfo = `RAID (${payload.data.viewers})`;
                    sublineText = 'brought their chat over';
                    break;
                }
                case 'Donation': {
                    if (payload.source !== 'Kofi') return null;
                    username = payload.data.from;
                    avatarUrl = 'https://raw.githubusercontent.com/tawmae/tawmae.github.io/refs/heads/main/assets/media/kofi%20placeholder.webp';
                    const currencySymbols = { USD: '$', EUR: '€', GBP: '£' };
                    const symbol = currencySymbols[payload.data.currency] || payload.data.currency;
                    eventInfo = `KOFI ${symbol}${payload.data.amount}`;
                    sublineText = 'sent a coffee';
                    break;
                }
                case 'WatchStreak': {
                    if (urlParams.watchstreaks === 'false') return null;
                    username = payload.data.displayName || payload.data.userName;
                    avatarUrl = await fetchAvatar(payload.data.userName);
                    eventInfo = `X${payload.data.watchStreak} WATCHSTREAK`;
                    sublineText = 'keeps showing up';
                    break;
                }
                default:
                    return null;
            }

            return { username, eventInfo, avatarUrl, sublineText };
        }

        async function handleQueuedEvent(payload) {
            const built = await buildEventFromPayload(payload);
            if (!built) return;
            await addEventNotification(built.username, built.eventInfo, built.avatarUrl, built.sublineText);
        }

        async function processQueue() {
            isProcessingQueue = true;
            while (eventQueue.length > 0) {
                const payload = eventQueue.shift();
                await handleQueuedEvent(payload);
            }
            isProcessingQueue = false;
        }

        function queueEvent(payload) {
            if (!payload) return;
            eventQueue.push(payload);
            if (!isProcessingQueue) processQueue();
        }

        function initClient() {
            const client = new StreamerbotClient({
                host: urlParams.address,
                port: parseInt(urlParams.port, 10),
                endpoint: '/'
            });

            client.on('Twitch.Follow', e => {
                queueEvent({ type: 'Follow', source: 'Twitch', data: e.data });
            });

            client.on('Twitch.Cheer', e => {
                queueEvent({ type: 'Cheer', source: 'Twitch', data: e.data });
            });

            client.on('Twitch.Sub', e => {
                queueEvent({ type: 'Sub', source: 'Twitch', data: e.data });
            });

            client.on('Twitch.ReSub', e => {
                queueEvent({ type: 'ReSub:Legacy', source: 'Twitch', data: e.data });
            });

            client.on('Twitch.SubMessage', e => {
                queueEvent({ type: 'ReSub', source: 'Twitch', data: e.data });
            });

            client.on('Twitch.GiftSub', e => {
                queueEvent({ type: 'GiftSub', source: 'Twitch', data: e.data });
            });

            client.on('Twitch.GiftBomb', e => {
                queueEvent({ type: 'GiftBomb', source: 'Twitch', data: e.data });
            });

            client.on('Twitch.Raid', e => {
                queueEvent({ type: 'Raid', source: 'Twitch', data: e.data });
            });

            client.on('Kofi.Donation', e => {
                queueEvent({ type: 'Donation', source: 'Kofi', data: e.data });
            });

            client.on('Twitch.WatchStreak', e => {
                queueEvent({ type: 'WatchStreak', source: 'Twitch', data: e.data });
            });
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') clearEvents();
        });

        applyDynamicStyles();
        loadStoredEvents();
        initClient();
    </script>
</body>

</html>
