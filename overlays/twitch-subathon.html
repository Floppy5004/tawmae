<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>tawmae.xyz - TWITCH SUBATHON - v.1.0.0</title>
  <script src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/iconify-icon@1/dist/iconify-icon.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@splidejs/splide/dist/css/splide.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/@splidejs/splide/dist/js/splide.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3/dist/ScrollToPlugin.min.js"></script>
  <style>
    :root {
      --box-width: 380px;
      --glass: rgba(255, 255, 255, 0.1);
      --radius: 16px;
      --font-color: #fff;
      --zoom: 1;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: "Poppins", sans-serif;
      color: var(--font-color);
      background: black;
    }

    .wrapper {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      transform: scale(var(--zoom));
      transform-origin: top right;
    }

    .glass-box {
      width: var(--box-width);
      background: var(--glass);
      border: 1px solid rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: var(--radius);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
      overflow: hidden;
      position: relative;
    }

    .timer-title {
      padding-top: 8px;
      text-align: center;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0.9;
      text-shadow: 2px 1px 3px rgba(0, 0, 0, 0.81);
    }

    .timer {
      padding: 6px 40px 6px;
      font-size: 48px;
      font-weight: 700;
      text-align: center;
      letter-spacing: 1px;
      text-shadow: 2px 1px 3px rgba(0, 0, 0, 0.81);
    }

    .icons {
      padding: 6px 10px;
      filter: drop-shadow(2px 1px 3px rgba(0, 0, 0, 0.4));
    }

    .splide__track {
      overflow: hidden;
    }

    .splide__list {
      display: flex;
      align-items: stretch;
    }

    .splide__slide {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 72px;
    }

    .triple {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
      padding: 0 8px;
    }

    .group {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 20px;
      font-weight: 600;
      text-shadow: 2px 1px 3px rgba(0, 0, 0, 0.81);
    }

    .group iconify-icon {
      font-size: 28px;
    }

    .group .icon-img {
      width: 28px;
      height: 28px;
      object-fit: contain;
    }

    .single {
      font-size: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
      text-shadow: 2px 1px 3px rgba(0, 0, 0, 0.81);
      padding: 0 10px;
      text-align: center;
    }

    .single iconify-icon {
      font-size: 22px;
    }

    .single .icon-img {
      width: 22px;
      height: 22px;
      object-fit: contain;
    }

    .goals {
      display: flex;
      flex-direction: column;
    }

    .goals-header {
      padding: 10px 16px 0;
      font-weight: 700;
      font-size: 18px;
      text-shadow: 2px 1px 3px rgba(0, 0, 0, 0.81);
    }

    .goals-scroll {
      overflow: hidden;
      border-radius: var(--radius);
    }

    .goals-inner {
      padding: 8px 16px 12px;
      display: flex;
      flex-direction: column;
    }

    .goal {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 0;
      font-size: 16px;
      text-shadow: 2px 1px 3px rgba(0, 0, 0, 0.81);
    }

    .goal iconify-icon {
      font-size: 22px;
      transition: opacity 0.25s ease, filter 0.25s ease;
    }

    .goal .icon-img {
      width: 22px;
      height: 22px;
      object-fit: contain;
      transition: opacity 0.25s ease, filter 0.25s ease;
    }

    .goal.done>span {
      text-decoration: line-through;
      opacity: 0.6;
    }

    .goal.done iconify-icon,
    .goal.done .icon-img {
      filter: grayscale(100%);
      opacity: 0.5;
    }

    .group iconify-icon,
    .single iconify-icon,
    .goal iconify-icon {
      filter: drop-shadow(2px 1px 3px rgba(0, 0, 0, 0.4));
    }

    .group .icon-img,
    .single .icon-img,
    .goal .icon-img {
      filter: drop-shadow(2px 1px 3px rgba(0, 0, 0, 0.4));
    }

    .hidden {
      display: none;
    }

    .status-footer {
      width: var(--box-width);
      align-self: flex-start;
      padding: 8px 12px;
      font-size: 16px;
      font-weight: 700;
      border-radius: var(--radius);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.25);
      text-align: center;
      opacity: 1;
      display: block;
    }

    .status-footer.is-error {
      background: rgba(255, 61, 61, 0.25);
      color: #ffdede;
      border-color: rgba(255, 61, 61, 0.6);
    }

    .status-footer.is-warn {
      background: rgba(255, 200, 0, 0.22);
      color: #fff4cc;
      border-color: rgba(255, 200, 0, 0.55);
    }

    .status-footer.is-soft-warn {
      background: rgba(255, 159, 41, 0.2);
      color: #ffe6c7;
      border-color: rgba(255, 159, 41, 0.5);
    }

    .status-footer.is-finished {
      background: rgba(152, 255, 183, 0.18);
      color: #b8ffcc;
      border-color: rgba(152, 255, 183, 0.55);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
    }

    .status-footer.is-paused {
      background: rgba(0, 191, 255, 0.2);
      color: #e4f6ff;
      border-color: rgba(0, 191, 255, 0.55);
    }

    .status-footer.is-ended {
      background: rgba(102, 200, 120, 0.22);
      color: #d4ffde;
      border-color: rgba(102, 200, 120, 0.55);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
    }

    .event-flash-bottom {
      align-self: flex-end;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.65));
      margin-right: 32px;
    }

    .event-flash-bottom.hidden {
      display: none;
    }

    .event-flash-bottom .line1 {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 24px;
      font-weight: 900;
      color: #b9f7c9;
    }

    .event-flash-bottom .line1 iconify-icon {
      font-size: 30px;
    }

    .event-flash-bottom .line2 {
      font-size: 20px;
      font-weight: 800;
      color: #b9f7c9;
      opacity: 0.98;
    }

    .status-footer iconify-icon {
      vertical-align: -0.15em;
    }

    .goal {
      position: relative
    }

    .goal .strike {
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      height: 2px;
      transform: translateY(-50%) scaleX(0);
      transform-origin: left center;
      background: linear-gradient(90deg, #fff, rgba(255, 255, 255, .2));
      border-radius: 2px;
      opacity: .9;
      pointer-events: none
    }
  </style>
</head>

<body>
  <div class="wrapper">
    <div class="glass-box" id="timerBox">
      <div class="timer-title" id="mainTitle">SUBATHON</div>
      <div class="timer" id="timer">00:00:00</div>
    </div>

    <div class="glass-box icons" id="rotatorBox">
      <div id="icons-splide" class="splide" aria-label="Icons Rotation">
        <div class="splide__track">
          <ul class="splide__list" id="splideList"></ul>
        </div>
      </div>
    </div>

    <div class="glass-box goals" id="goalsBox">
      <div class="goals-header" id="goalTitle">Goals:</div>
      <div class="goals-scroll" id="goalsScroll">
        <div class="goals-inner" id="goalsInner"></div>
      </div>
    </div>

    <div class="status-footer is-error" id="statusFooter">Connecting…</div>

    <div class="event-flash-bottom hidden" id="eventFlashBtm">
      <div class="line1">
        <iconify-icon id="flashIconBtm" icon="mdi:information-outline"></iconify-icon>
        <span id="flashCountBtm">+0</span>
      </div>
      <div class="line2" id="flashTimeBtm">+00:00:00</div>
    </div>
  </div>

  <script>
    loadFont("Poppins");
    // ====================================================
    const urlParamsRaw = new URLSearchParams(location.search);
    const urlParams = {};
    for (const [k, v] of urlParamsRaw.entries()) {
      urlParams[k.toLowerCase()] = v;
    }
    // ====================================================
    const address = urlParams["address"] || "127.0.0.1";
    const port = parseInt(urlParams["port"] || "8080", 10);
    const password = urlParams["password"] || undefined;
    // ====================================================
    const SETTINGS_VAR = "tawmae_Settings_TWITCH SUBATHON";
    const DATA_VAR = "tawmae_data_TWITCH SUBATHON";
    let splide;
    let goalsTl;
    let cfgCache = {};
    let dataCache = null;
    let prevData = null;
    let connectedOnce = false;
    let hasCfg = false;
    let hasData = false;
    let isConnected = false;
    let prevRemainSec = null;
    let finishTriggerSent = false;
    let firedGoals = new Set();
    let goalTriggersArmed = false;
    let goalViewportCount = 5;
    let manualEnded = false;
    let manualEndedAt = null;
    let manualRemainAt = null;
    let animatedGoals = new Set(); let goalAnimQueue = []; let goalAnimBusy = false;
    const timerStuff = { format: "hh:mm:ss", eta: new Date(), started: null };
    const counts = { subs: 0, bits: 0, donations: 0, charitydonations: 0, follows: 0, raids: 0, channelPoints: 0, loyaltyPoints: 0 };
    const displayCounts = {};
    // ====================================================
    const els = {
      timerBox: document.getElementById("timerBox"),
      timer: document.getElementById("timer"),
      mainTitle: document.getElementById("mainTitle"),
      rotatorBox: document.getElementById("rotatorBox"),
      goalsBox: document.getElementById("goalsBox"),
      goalsScroll: document.getElementById("goalsScroll"),
      goalsInner: document.getElementById("goalsInner"),
      goalTitle: document.getElementById("goalTitle"),
      splideList: document.getElementById("splideList"),
      statusFooter: document.getElementById("statusFooter"),
      eventFlashBtm: document.getElementById("eventFlashBtm"),
      flashIconBtm: document.getElementById("flashIconBtm"),
      flashCountBtm: document.getElementById("flashCountBtm"),
      flashTimeBtm: document.getElementById("flashTimeBtm")
    };
    // ====================================================
    function loadFont(name) {
      if (!name) return;
      const f = name.trim().replace(/\s+/g, "+");
      const id = `font-${f}`;
      if (document.getElementById(id)) return;
      const link = document.createElement("link");
      link.id = id;
      link.rel = "stylesheet";
      link.href = `https://fonts.googleapis.com/css2?family=${f}:wght@400;600;700&display=swap`;
      document.head.appendChild(link);
    }
    // ====================================================
    function parseArrayOrEmpty(v) {
      if (!v) return [];
      if (Array.isArray(v)) return v;
      if (typeof v === "string") {
        try {
          const p = JSON.parse(v);
          return Array.isArray(p) ? p : [];
        } catch {
          return [];
        }
      }
      return [];
    }
    // ====================================================
    function parseJsonOrEmpty(v) {
      if (!v) return {};
      if (typeof v === "object") return v;
      if (typeof v === "string") {
        try {
          return JSON.parse(v);
        } catch {
          return {};
        }
      }
      return {};
    }
    // ====================================================
    function readToggle(v) {
      const o = parseJsonOrEmpty(v);
      return { enabled: !!o.enabled, value: Number(o.value) || 0 };
    }
    // ====================================================
    function isIconUrl(s) {
      const v = String(s || "");
      return /^https?:\/\//i.test(v) || /^data:image\//i.test(v) || /\.(png|jpg|jpeg|gif|webp|svg)(\?.*)?$/i.test(v);
    }
    // ====================================================
    function makeIconElement(icon, size) {
      if (isIconUrl(icon)) {
        const img = document.createElement("img");
        img.src = icon;
        img.className = "icon-img";
        img.style.width = size + "px";
        img.style.height = size + "px";
        return img;
      }
      const ico = document.createElement("iconify-icon");
      ico.setAttribute("icon", icon || "mdi:information-outline");
      ico.style.fontSize = size + "px";
      return ico;
    }
    // ====================================================
    function clamp(n, min, max) {
      return Math.min(Math.max(n, min), max);
    }
    // ====================================================
    function hexToRgb(hex) {
      let h = String(hex || "").replace("#", "").trim();
      if (h.length === 3) h = h.split("").map(x => x + x).join("");
      if (!/^[0-9a-fA-F]{6}$/.test(h)) h = "07070b";
      const num = parseInt(h, 16);
      return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
    }
    // ====================================================
    function rgba(r, g, b, a) {
      return `rgba(${r},${g},${b},${a})`;
    }
    // ====================================================
    function makeGlass(bg, trans) {
      const { r, g, b } = hexToRgb(bg);
      const a = clamp((Number(trans) || 0) / 100, 0, 1);
      return rgba(r, g, b, a);
    }
    // ====================================================
    function setCssVar(k, v) {
      document.documentElement.style.setProperty(k, String(v));
    }
    // ====================================================
    function parseTimeToSeconds(s) {
      const parts = String(s || "")
        .split(":")
        .map(x => parseInt(x, 10))
        .filter(x => !isNaN(x));
      while (parts.length < 4) parts.unshift(0);
      const [dd, hh, mm, ss] = parts.slice(-4);
      return dd * 86400 + hh * 3600 + mm * 60 + ss;
    }
    // ====================================================
    function two(n) {
      return String(n).padStart(2, "0");
    }
    // ====================================================
    function formatSeconds(total, fmt) {
      const sign = total < 0 ? "-" : "";
      let t = Math.max(0, Math.floor(Math.abs(total)));
      const d = Math.floor(t / 86400);
      t -= d * 86400;
      const h = Math.floor(t / 3600);
      t -= h * 3600;
      const m = Math.floor(t / 60);
      t -= m * 60;
      const s = t;
      if (fmt === "dd:hh:mm:ss") return `${sign}${two(d)}:${two(h)}:${two(m)}:${two(s)}`;
      if (fmt === "dd:hh:mm") return `${sign}${two(d)}:${two(h)}:${two(m)}`;
      if (fmt === "hh:mm:ss") return `${sign}${two(d * 24 + h)}:${two(m)}:${two(s)}`;
      if (fmt === "hh:mm") return `${sign}${two(d * 24 + h)}:${two(m)}`;
      return `${sign}${two(d)}:${two(h)}:${two(m)}:${two(s)}`;
    }
    // ====================================================
    function getUserTimeZone() {
      return (cfgCache && cfgCache.timezone) || Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";
    }
    // ====================================================
    function formatDateInTZ(input, tz) {
      const d = input instanceof Date ? input : new Date((Number(input) || 0) * 1000);
      return d
        .toLocaleString("en-CA", {
          timeZone: tz,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          hour12: false
        })
        .replace(",", "");
    }
    // ====================================================
    function ensureStrike(row) { let s = row.querySelector(".strike"); if (!s) { s = document.createElement("div"); s.className = "strike"; row.appendChild(s) } return s }
    // ====================================================
    function snapshotPositions() { const m = new Map(); Array.from(els.goalsInner.children).forEach(el => m.set(el, el.getBoundingClientRect())); return m }
    // ====================================================
    function reorderGoals() { const items = Array.from(els.goalsInner.querySelectorAll(".goal")); const pending = items.filter(g => !g.classList.contains("done")).sort((a, b) => Number(a.dataset.index) - Number(b.dataset.index)); const done = items.filter(g => g.classList.contains("done")).sort((a, b) => Number(a.dataset.index) - Number(b.dataset.index));[...pending, ...done].forEach(g => els.goalsInner.appendChild(g)) }
    // ====================================================
    function flipToNewOrder(before) { const after = Array.from(els.goalsInner.children); after.forEach(el => { const f = before.get(el); const l = el.getBoundingClientRect(); const dy = f ? f.top - l.top : 0; gsap.fromTo(el, { y: dy }, { y: 0, duration: .45, ease: "power2.inOut" }) }) }
    // ====================================================
    function runNextGoalAnim() { if (!goalAnimQueue.length) { goalAnimBusy = false; if (goalsTl) goalsTl.resume(); updateGoalsViewportAuto(goalViewportCount); return } goalAnimBusy = true; const row = goalAnimQueue.shift(); const strike = ensureStrike(row); if (goalsTl) goalsTl.pause(); const before = snapshotPositions(); gsap.set(strike, { scaleX: 0 }); gsap.timeline().to(strike, { scaleX: 1, duration: .35, ease: "power2.out" }).add(() => { reorderGoals(); flipToNewOrder(before) }).add(() => runNextGoalAnim(), "+=0.02") }
    // ====================================================
    function queueGoalAnimation(row) { if (animatedGoals.has(row.dataset.key)) return; animatedGoals.add(row.dataset.key); goalAnimQueue.push(row); if (!goalAnimBusy) runNextGoalAnim() }
    // ====================================================
    function setSpansForKey(key, val) {
      const spans = document.querySelectorAll(`[data-count-key="${key}"]`);
      const txt = needsCurrencyKey(key) ? formatCurrency(val) : String(Math.round(val));
      spans.forEach(s => s.textContent = txt);
    }
    // ====================================================
    function popSpansForKey(key) {
      const spans = document.querySelectorAll(`[data-count-key="${key}"]`);
      spans.forEach(s => {
        gsap.fromTo(s, { scale: 1 }, { scale: 1.12, yoyo: true, repeat: 1, duration: 0.12, ease: "power1.out" });
      });
    }
    // ====================================================
    function animateCountKey(key, newVal) {
      const to = Number(newVal || 0);
      const from = Number(displayCounts[key] ?? to);
      if (to <= from) {
        displayCounts[key] = to;
        setSpansForKey(key, to);
        return;
      }
      const obj = { v: from };
      const spanDelta = Math.abs(to - from);
      const dur = Math.min(1.0, 0.35 + Math.log10(1 + spanDelta) * 0.25);
      gsap.to(obj, {
        v: to,
        duration: dur,
        ease: "power2.out",
        onUpdate: () => setSpansForKey(key, obj.v),
        onComplete: () => { displayCounts[key] = to; }
      });
      popSpansForKey(key);
    }
    // ====================================================
    function pickRotatorIcon(category, cfg) {
      const c = String(category || "").toLowerCase();
      if (c.includes("prime")) return cfg.icon_subPrime;
      if (c.includes("tier 1")) return cfg.icon_subT1;
      if (c.includes("tier 2")) return cfg.icon_subT2;
      if (c.includes("tier 3")) return cfg.icon_subT3;
      if (c.includes("bit")) return cfg.icon_Bits;
      if (c.includes("charity")) return cfg.icon_CharityDonation;
      if (c.includes("donation")) return cfg.icon_Donation;
      if (c.includes("follow")) return cfg.icon_Follows;
      if (c.includes("raid")) return cfg.icon_Raids;
      if (c.includes("channel")) return cfg.icon_ChannelPoints;
      if (c.includes("loyalty")) return cfg.icon_LoyaltyPoints;
      if (c.includes("clock")) return "mdi:clock-outline";
      if (c.includes("no icon")) return "";
      return "mdi:information-outline";
    }
    // ====================================================
    function makeRotatorCountSlides(cfg) {
      const enabledTriples = [];
      const add = arr => {
        if (arr.length) enabledTriples.push(arr);
      };
      const active = [];
      const t1 = readToggle(cfg.addedTime_t1Sub).enabled;
      const t2 = readToggle(cfg.addedTime_t2Sub).enabled;
      if (t1 || t2) active.push({ key: "subs", icon: cfg.icon_subT1 || cfg.icon_subPrime });
      if (readToggle(cfg.addedTime_bits).enabled) active.push({ key: "bits", icon: cfg.icon_Bits });
      if (readToggle(cfg.addedTime_donations).enabled) active.push({ key: "donations", icon: cfg.icon_Donation });
      if (readToggle(cfg.addedTime_charityDonations).enabled) active.push({ key: "charitydonations", icon: cfg.icon_CharityDonation });
      if (readToggle(cfg.addedTime_follow).enabled) active.push({ key: "follows", icon: cfg.icon_Follows });
      if (readToggle(cfg.addedTime_raid).enabled) active.push({ key: "raids", icon: cfg.icon_Raids });
      if (readToggle(cfg.addedTime_channelPoints).enabled) active.push({ key: "channelPoints", icon: cfg.icon_ChannelPoints });
      if (readToggle(cfg.addedTime_loyaltyPoints).enabled) active.push({ key: "loyaltyPoints", icon: cfg.icon_LoyaltyPoints });
      for (let i = 0; i < active.length; i += 3) add(active.slice(i, i + 3));
      const slides = [];
      enabledTriples.forEach(group => {
        const li = document.createElement("li");
        li.className = "splide__slide";
        const triple = document.createElement("div");
        triple.className = "triple";
        group.forEach(item => {
          const wrap = document.createElement("div");
          wrap.className = "group";
          wrap.appendChild(makeIconElement(item.icon, 28));
          const span = document.createElement("span");
          span.dataset.countKey = item.key;
          span.textContent = formatCountForKey(item.key, counts[item.key]);
          wrap.appendChild(span);
          triple.appendChild(wrap);
        });
        li.appendChild(triple);
        slides.push(li);
      });
      return slides;
    }
    // ====================================================
    function clearEl(n) {
      while (n.firstChild) n.removeChild(n.firstChild);
    }
    // ====================================================
    function makeRotator(cfg) {
      const tz = getUserTimeZone();
      const texts = parseArrayOrEmpty(cfg.rotator_texts);
      clearEl(els.splideList);
      if (cfg.show_RotatorCurrentGoalCounts) {
        makeRotatorCountSlides(cfg).forEach(s => els.splideList.appendChild(s));
      }
      const startedUnix = Number(dataCache?.general?.startedAt_Unix || 0);
      const startedStr = startedUnix > 0 ? formatDateInTZ(startedUnix, tz) : "";
      const etaDate = new Date(Date.now() + (calcTimeLeft().remain || 0) * 1000);
      const endStr = formatDateInTZ(etaDate, tz);
      texts.forEach(it => {
        const li = document.createElement("li");
        li.className = "splide__slide";
        const single = document.createElement("div");
        single.className = "single";
        const iconVal = pickRotatorIcon(it.category, cfg);
        if (iconVal) single.appendChild(makeIconElement(iconVal, 22));
        const span = document.createElement("span");
        span.textContent = String(it.text || "")
          .replace(/%startedAt%/gi, startedStr || "")
          .replace(/%endAt%/gi, endStr || "");
        single.appendChild(span);
        li.appendChild(single);
        els.splideList.appendChild(li);
      });
      if (splide) {
        try {
          splide.destroy();
        } catch { }
      }
      const intervalMs = Math.max(1000, Math.floor((Number(cfg.rotatorInterval) || 8) * 1000));
      splide = new Splide("#icons-splide", {
        type: "fade",
        rewind: true,
        autoplay: true,
        interval: intervalMs,
        speed: 500,
        arrows: false,
        pagination: false,
        pauseOnHover: false,
        pauseOnFocus: false
      });
      splide.mount();
      updateCountSpans();
    }
    // ====================================================
    function selectorToKey(sel) {
      const s = String(sel || "").toLowerCase();
      if (s.includes("no icon")) return "noicon";
      if (s.includes("charity")) return "charitydonations";
      if (s.includes("donation")) return "donations";
      if (s.includes("subs")) return "subs";
      if (s.includes("bits")) return "bits";
      if (s.includes("follow")) return "follows";
      if (s.includes("raid")) return "raids";
      if (s.includes("channel")) return "channelPoints";
      if (s.includes("loyalty")) return "loyaltyPoints";
      return "";
    }
    // ====================================================
    function iconForKey(key, cfg) {
      const map = {
        subs: cfg.icon_subT1 || cfg.icon_subPrime,
        bits: cfg.icon_Bits,
        donations: cfg.icon_Donation,
        charitydonations: cfg.icon_CharityDonation,
        follows: cfg.icon_Follows,
        raids: cfg.icon_Raids,
        channelPoints: cfg.icon_ChannelPoints,
        loyaltyPoints: cfg.icon_LoyaltyPoints,
      };
      return map[key] || (cfg.icon_subT1 || cfg.icon_subPrime);
    }
    // ====================================================
    function makeGoals(cfg) {
      const list = parseArrayOrEmpty(cfg.goalsList);
      clearEl(els.goalsInner);

      list.forEach((g, i) => {
        const kindKey = selectorToKey(g.selector);
        const row = document.createElement("div");
        row.className = "goal";
        row.dataset.index = String(i);
        row.dataset.kind = kindKey;
        row.dataset.target = String(g.amount || 0);
        row.dataset.name = String(g.text || "");
        row.dataset.key = `${row.dataset.kind}|${row.dataset.target}|${row.dataset.name}`;

        let icon = iconForKey(kindKey, cfg);
        let invisible = kindKey === "noicon";

        const iconEl = makeIconElement(icon, 22);
        if (invisible) {
          iconEl.style.opacity = "0";
          iconEl.style.pointerEvents = "none";
        }
        row.appendChild(iconEl);

        const span = document.createElement("span");
        const targetVal = Number(g.amount || 0);
        const displayAmt = needsCurrencyKey(kindKey) ? formatCurrency(targetVal) : String(targetVal);
        span.textContent = `${displayAmt} - ${g.text || ""}`;
        row.appendChild(span);
        els.goalsInner.appendChild(row);
      });

      Array.from(els.goalsInner.querySelectorAll(".goal")).forEach(g => {
        const kind = g.dataset.kind;
        const target = parseFloat(g.dataset.target || "0") || 0;
        const cv = Number(counts[kind] || 0);
        if (cv >= target && target > 0) {
          const key = g.dataset.key || "";
          if (key) firedGoals.add(key);
        }
      });

      updateGoalsDoneAndSort();
      updateGoalsViewportAuto(goalViewportCount);
    }
    // ====================================================
    function updateGoalsDoneAndSort() {
      const items = Array.from(els.goalsInner.querySelectorAll(".goal"));
      let anyNew = false;
      items.forEach(g => {
        const kind = g.dataset.kind; if (kind === "noicon") return;
        const target = parseFloat(g.dataset.target || "0") || 0;
        const cv = Number(counts[kind] || 0);
        const wasDone = g.classList.contains("done");
        const nowDone = cv >= target && target > 0;
        if (nowDone) g.classList.add("done"); else g.classList.remove("done");
        if (goalTriggersArmed && !wasDone && nowDone) {
          const key = g.dataset.key || "";
          if (key && !firedGoals.has(key)) {
            firedGoals.add(key);
            fireGoalTrigger(g.dataset.name || "", cv, g.dataset.kind || "");
            queueGoalAnimation(g);
            anyNew = true;
          }
        }
      });
      if (!anyNew) {
        const before = snapshotPositions();
        reorderGoals();
        flipToNewOrder(before);
      }
    }

    // ====================================================
    gsap.registerPlugin(ScrollToPlugin);
    // ====================================================
    function setGoalsViewport(n) {
      const items = Array.from(els.goalsInner.querySelectorAll(".goal"));
      if (!items.length) return;
      const take = Math.min(n, items.length);
      let h = 0;
      for (let i = 0; i < take; i++) h += items[i].offsetHeight;
      const cs = getComputedStyle(els.goalsInner);
      const vpad = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
      const targetH = Math.ceil(h + vpad);
      els.goalsScroll.style.height = targetH + "px";
      els.goalsScroll.style.maxHeight = targetH + "px";
    }
    // ====================================================
    function makeGoalsAutoscroll() {
      if (goalsTl) goalsTl.kill();
      const last = els.goalsInner.querySelector(".goal:last-of-type");
      if (!last) {
        els.goalsScroll.scrollTop = 0;
        return;
      }
      const maxByBottom = Math.max(0, last.offsetTop + last.offsetHeight - els.goalsScroll.clientHeight);
      const maxNatural = Math.max(0, els.goalsScroll.scrollHeight - els.goalsScroll.clientHeight);
      const max = Math.min(maxByBottom, maxNatural);
      if (max <= 0) {
        els.goalsScroll.scrollTop = 0;
        return;
      }
      const pause = 10;
      const speed = 40;
      const dur = max / speed;
      els.goalsScroll.scrollTop = 0;
      goalsTl = gsap.timeline({ repeat: -1, defaults: { ease: "none" } });
      goalsTl.to({}, { duration: pause });
      goalsTl.to(els.goalsScroll, { scrollTo: { y: max }, duration: dur });
      goalsTl.to({}, { duration: pause });
      goalsTl.to(els.goalsScroll, { scrollTo: { y: 0 }, duration: dur });
    }
    // ====================================================
    function updateGoalsViewportAuto(n) {
      requestAnimationFrame(() => {
        setGoalsViewport(n);
        makeGoalsAutoscroll();
      });
      setTimeout(() => {
        setGoalsViewport(n);
        makeGoalsAutoscroll();
      }, 120);
    }
    // ====================================================
    function applyTheme(cfg) {
      loadFont(cfg.font || "Poppins");
      document.body.style.fontFamily = `'${cfg.font || "Poppins"}', sans-serif`;
      setCssVar("--font-color", cfg.fontColor || "#FFFFFF");
      setCssVar("--glass", makeGlass(cfg.backgroundColor || "#07070b", cfg.backgroundTransparency == null ? 10 : cfg.backgroundTransparency));
      setCssVar("--radius", cfg.roundedCorners === false ? "0px" : "16px");
      setCssVar("--zoom", String(parseFloat(cfg.zoomLevel || "1.0") || 1));
      els.mainTitle.textContent = cfg.mainTitle || "SUBATHON";
      els.goalTitle.textContent = cfg.goalTitle || "Goals:";
      els.rotatorBox.style.display = cfg.show_Rotator === false ? "none" : "block";
      els.goalsBox.style.display = cfg.show_Goals === false ? "none" : "block";
    }
    // ====================================================
    function makeDefaultData() {
      return {
        general: { isActive: false, startedAt_Unix: null, endedAt_Unix: null, addedSecondsTotal: 0 },
        pauses: { isPaused: false, pausedSinceUnix: null, ranges: [] },
        events: {
          primesubs: { count: 0, addedSecondsPer: 0, totalSecondsAdded: 0 },
          t1subs: { count: 0, addedSecondsPer: 0, totalSecondsAdded: 0 },
          t2subs: { count: 0, addedSecondsPer: 0, totalSecondsAdded: 0 },
          t3subs: { count: 0, addedSecondsPer: 0, totalSecondsAdded: 0 },
          bits: { count: 0, addedSecondsPer: 0, totalSecondsAdded: 0 },
          donations: { count: 0, addedSecondsPer: 0, totalSecondsAdded: 0 },
          follows: { count: 0, addedSecondsPer: 0, totalSecondsAdded: 0 },
          channelpointrewards: { count: 0, addedSecondsPer: 0, totalSecondsAdded: 0 },
          raids: { count: 0, addedSecondsPer: 0, totalSecondsAdded: 0 },
          loyaltypoints: { count: 0, addedSecondsPer: 0, totalSecondsAdded: 0 }
        }
      };
    }
    // ====================================================
    function updateCountsFromData(d) {
      const e = d?.events || {};
      const subs =
        (Number(e?.primesubs?.count) || 0) +
        (Number(e?.t1subs?.count) || 0) +
        (Number(e?.t2subs?.count) || 0) +
        (Number(e?.t3subs?.count) || 0);
      counts.subs = subs;
      counts.bits = Number(e?.bits?.count) || 0;
      counts.donations = Number(e?.donations?.count) || 0;
      counts.charitydonations = Number(e?.charitydonations?.count) || 0;
      counts.follows = Number(e?.follows?.count) || 0;
      counts.raids = Number(e?.raids?.count) || 0;
      counts.channelPoints = Number(e?.channelpointrewards?.count) || 0;
      counts.loyaltyPoints = Number(e?.loyaltypoints?.count) || 0;
      updateCountSpans();
      updateGoalsDoneAndSort();
    }
    // ====================================================
    function updateCountSpans() {
      Object.keys(counts).forEach(k => animateCountKey(k, counts[k]));
    }
    // ====================================================
    function applySettings(cfgRaw) {
      const cfg = typeof cfgRaw === "string" ? parseJsonOrEmpty(cfgRaw) : cfgRaw || {};
      cfgCache = cfg;
      timerStuff.format = cfg.timeFormat || "hh:mm:ss";
      goalViewportCount = Math.max(1, Math.round(Number(cfg.goalToShow) || 5));
      els.timer.textContent = formatSeconds(parseTimeToSeconds(cfg.startingTime || "00:00:00:00"), timerStuff.format);
      applyTheme(cfg);
      makeRotator(cfg);
      makeGoals(cfg);
      updateCountsFromData(dataCache || makeDefaultData());
      updateCountSpans();
      updateGoalsDoneAndSort();
      setStatusFromState();
      updateGoalsViewportAuto(goalViewportCount);
    }
    // ====================================================
    function sumPauses(r) {
      if (!Array.isArray(r)) return 0;
      return r.reduce((a, b) => a + (Number(b) || 0), 0);
    }
    // ====================================================
    function calcTimeLeft() {
      const base = parseTimeToSeconds(cfgCache?.startingTime || "00:00:00:00");
      const d = dataCache || makeDefaultData();
      const add = Number(d?.general?.addedSecondsTotal || 0);
      const started = Number(d?.general?.startedAt_Unix || 0);
      const ended = Number(d?.general?.endedAt_Unix || 0);
      const now = Math.floor(Date.now() / 1000);
      let paused = sumPauses(d?.pauses?.ranges || []);
      if (d?.pauses?.isPaused && d?.pauses?.pausedSinceUnix) paused += Math.max(0, now - Number(d.pauses.pausedSinceUnix));
      let elapsed = 0;
      if (d?.general?.isActive && started > 0) elapsed = Math.max(0, now - started - paused);
      else if (!d?.general?.isActive && started > 0 && ended > 0) elapsed = Math.max(0, ended - started - paused);
      const remain = Math.max(0, base + add - elapsed);
      return { remain, isActive: !!d?.general?.isActive };
    }
    // ====================================================
    function showFooter(html, variant) {
      const el = els.statusFooter;
      const cls =
        variant === "error" ? "is-error" :
          variant === "warn" ? "is-warn" :
            variant === "soft-warn" ? "is-soft-warn" :
              variant === "finished" ? "is-finished" :
                variant === "paused" ? "is-paused" :
                  variant === "ended" ? "is-ended" : "";
      const targetClass = `status-footer ${cls}`;
      const visible = getComputedStyle(el).display !== "none";

      if (!showFooter._last) showFooter._last = { html: "", cls: "", visible: false };

      if ((html || "") === showFooter._last.html && targetClass === showFooter._last.cls && visible) return;

      if (!html) {
        gsap.killTweensOf(el);
        if (!visible) {
          el.innerHTML = "";
          el.className = "status-footer";
          el.style.display = "none";
        } else {
          gsap.to(el, {
            opacity: 0,
            duration: 0.25,
            onComplete: () => {
              el.innerHTML = "";
              el.className = "status-footer";
              el.style.display = "none";
            }
          });
        }
        showFooter._last = { html: "", cls: "", visible: false };
        return;
      }

      if (!visible) {
        el.className = targetClass;
        el.innerHTML = html;
        el.style.opacity = 0;
        el.style.display = "block";
        gsap.to(el, { opacity: 1, duration: 0.25 });
        showFooter._last = { html, cls: targetClass, visible: true };
        return;
      }

      gsap.killTweensOf(el);
      gsap.to(el, {
        opacity: 0,
        duration: 0.15,
        onComplete: () => {
          el.className = targetClass;
          el.innerHTML = html;
          gsap.to(el, { opacity: 1, duration: 0.2 });
        }
      });
      showFooter._last = { html, cls: targetClass, visible: true };
    }
    // ====================================================

    function setStatusFromState() {
      if (!isConnected) {
        showFooter("Disconnected", "error");
        return;
      }
      if (!hasCfg) {
        showFooter("Setup incomplete", "warn");
        return;
      }

      if (manualEnded) {
        showFooter(cfgCache.endedText || "Subathon ended", "ended");
        return;
      }

      if (!hasData) {
        showFooter(cfgCache.notStartedYetText || "Subathon has not started yet.", "soft-warn");
        return;
      }

      const d = dataCache || makeDefaultData();
      const startedAt = Number(d?.general?.startedAt_Unix || 0);
      const endedAt = Number(d?.general?.endedAt_Unix || 0);
      const paused = !!d?.pauses?.isPaused;
      const snap = calcTimeLeft();
      const totalPlanned = parseTimeToSeconds(cfgCache?.startingTime || "00:00:00:00") + Number(d?.general?.addedSecondsTotal || 0);
      const hadStart = startedAt > 0;
      const finished = snap.remain === 0 && totalPlanned > 0 && hadStart;

      if (!hadStart) { showFooter(cfgCache.notStartedYetText || "Subathon has not started yet.", "soft-warn"); return; }
      if (finished) { showFooter(`${cfgCache.completedText || "Subathon completed!"} <iconify-icon icon="gis:flag-finish"></iconify-icon>`, "finished"); return; }
      if (endedAt > 0) { showFooter(cfgCache.endedText || "Subathon ended", "ended"); return; }
      if (paused) { showFooter(`${cfgCache.pausedText || "Subathon paused"} <iconify-icon icon="mdi:pause-circle"></iconify-icon>`, "paused"); return; }

      showFooter("", null);
    }
    // ====================================================

    function needsCurrencyKey(k) { return k === "donations" || k === "charitydonations"; }
    // ====================================================
    function currencySuffix() { return " " + (cfgCache.currencySuffix || cfgCache.currencySymbol || "€"); }
    // ====================================================
    function formatCurrency(n) {
      const dec = Number.isInteger(cfgCache.currencyDecimals) ? cfgCache.currencyDecimals : 2;
      const loc = cfgCache.locale || "de-DE";
      const num = Number(n || 0);
      return num.toLocaleString(loc, { minimumFractionDigits: dec, maximumFractionDigits: dec }) + currencySuffix();
    }
    // ====================================================
    function formatCountForKey(k, v) {
      const n = Number(v || 0);
      return needsCurrencyKey(k) ? formatCurrency(n) : String(n);
    }

    // ====================================================
    let flashBusy = false;
    let flashQueue = [];
    // ====================================================
    function pickIconForEvent(key, cfg) {
      const map = {
        primesubs: cfg.icon_subPrime,
        t1subs: cfg.icon_subT1,
        t2subs: cfg.icon_subT2,
        t3subs: cfg.icon_subT3,
        bits: cfg.icon_Bits,
        donations: cfg.icon_Donation,
        charitydonations: cfg.icon_CharityDonation,
        follows: cfg.icon_Follows,
        channelpointrewards: cfg.icon_ChannelPoints,
        raids: cfg.icon_Raids,
        loyaltypoints: cfg.icon_LoyaltyPoints
      };
      const iconVal = map[key] || "mdi:information-outline";
      return iconVal;
    }
    // ====================================================
    function queueFlash(eventKey, icon, countDelta, secDelta) {
      flashQueue.push({ eventKey, icon, countDelta, secDelta });
      if (!flashBusy) runNextFlash();
    }
    // ====================================================
    function runNextFlash() {
      if (!flashQueue.length) {
        flashBusy = false;
        return;
      }
      flashBusy = true;
      const { eventKey, icon, countDelta, secDelta } = flashQueue.shift();
      const countText = "+" + (needsCurrencyKey(eventKey) ? formatCurrency(countDelta) : String(countDelta));

      if (isIconUrl(icon)) {
        const img = document.createElement("img");
        img.src = icon;
        img.className = "icon-img";
        img.style.width = "30px";
        img.style.height = "30px";
        els.flashIconBtm.replaceWith(img);
        els.flashIconBtm = img;
      } else {
        if (els.flashIconBtm.tagName.toLowerCase() !== "iconify-icon") {
          const ico = document.createElement("iconify-icon");
          ico.setAttribute("icon", icon || "mdi:information-outline");
          ico.style.fontSize = "30px";
          els.flashIconBtm.replaceWith(ico);
          els.flashIconBtm = ico;
        } else {
          els.flashIconBtm.setAttribute("icon", icon || "mdi:information-outline");
        }
      }
      els.flashCountBtm.textContent = countText;
      els.flashTimeBtm.textContent = `+${formatSeconds(Math.max(0, Math.floor(secDelta || 0)), timerStuff.format)}`;
      els.eventFlashBtm.classList.remove("hidden");
      gsap.killTweensOf(els.eventFlashBtm);
      gsap.set(els.eventFlashBtm, { opacity: 0, y: 10 });
      gsap
        .timeline()
        .to(els.eventFlashBtm, { opacity: 1, y: 0, duration: 0.25 })
        .to(els.eventFlashBtm, { opacity: 1, duration: 5.0 })
        .to(els.eventFlashBtm, { opacity: 0, y: -6, duration: 0.25 })
        .add(() => {
          els.eventFlashBtm.classList.add("hidden");
          runNextFlash();
        });
    }
    // ====================================================
    const eventKeys = [
      "primesubs",
      "t1subs",
      "t2subs",
      "t3subs",
      "bits",
      "donations",
      "charitydonations",
      "follows",
      "channelpointrewards",
      "raids",
      "loyaltypoints"
    ];
    // ====================================================
    function getEventChanges(prev, cur) {
      const out = [];
      if (!prev) return out;
      const pe = prev.events || {};
      const ce = cur.events || {};
      eventKeys.forEach(k => {
        const p = pe[k] || {};
        const c = ce[k] || {};
        const dCount = Math.max(0, (Number(c.count) || 0) - (Number(p.count) || 0));
        const tdiff = Math.max(0, (Number(c.totalSecondsAdded) || 0) - (Number(p.totalSecondsAdded) || 0));
        let dSecs = 0;
        if (tdiff > 0) dSecs = tdiff;
        else if (dCount > 0) {
          const per = Number(c.addedSecondsPer) || 0;
          if (per > 0) {
            if (k === "bits") dSecs = Math.floor(per * (dCount / 100));
            else dSecs = per * dCount;
          }
        }
        if (dCount > 0 || dSecs > 0) out.push({ key: k, dCount, dSecs });
      });
      if (!out.length) {
        const addDiff = Math.max(0, (Number(cur?.general?.addedSecondsTotal) || 0) - (Number(prev?.general?.addedSecondsTotal) || 0));
        if (addDiff > 0) out.push({ key: "unknown", dCount: 1, dSecs: addDiff });
      }
      return out;
    }
    // ====================================================
    function eventKeyToCountKey(k) {
      if (k === "primesubs" || k === "t1subs" || k === "t2subs" || k === "t3subs") return "subs";
      if (k === "bits") return "bits";
      if (k === "donations") return "donations";
      if (k === "charitydonations") return "charitydonations";
      if (k === "follows") return "follows";
      if (k === "channelpointrewards") return "channelPoints";
      if (k === "raids") return "raids";
      if (k === "loyaltypoints") return "loyaltyPoints";
      return "";
    }
    // ====================================================
    function applyData(newDataRaw) {
      const parsed = typeof newDataRaw === "string" ? parseJsonOrEmpty(newDataRaw) : newDataRaw || makeDefaultData();
      const d = parsed || makeDefaultData();
      const startedUnix = Number(d?.general?.startedAt_Unix || 0);
      timerStuff.started = startedUnix > 0 ? new Date(startedUnix * 1000) : null;

      const changes = getEventChanges(prevData, d);
      changes.forEach(ch => {
        const key = eventKeyToCountKey(ch.key);
        if (!key) return;
        animateCountKey(key, counts[key]);
      });
      prevData = d;
      dataCache = d;

      if (changes.length) {
        const e = d.events || {};
        for (const ch of changes) {
          const icon = pickIconForEvent(ch.key, cfgCache);
          queueFlash(ch.key, icon, ch.dCount, Math.max(0, Math.floor(ch.dSecs || 0)));

          if (ch.dSecs > 0) {
            const addedFormatted = formatSeconds(ch.dSecs, timerStuff.format);
            const currentSeconds = Math.max(0, calcTimeLeft().remain);
            const totalCount = Number(e[ch.key]?.count || 0);

            sb.executeCodeTrigger("subathon_time_added", {
              eventKey: ch.key,
              addedSeconds: Number(ch.dSecs || 0),
              addedFormatted,
              addedCount: Number(ch.dCount || 0),
              totalCount,
              currentTimestamp: formatSeconds(currentSeconds, timerStuff.format),
              currentSeconds
            }).catch(() => { });
          }
        }
      }

      updateCountsFromData(d);
      updateCountSpans();
      if (splide && splide.refresh) splide.refresh();
      setStatusFromState();
    }

    // ====================================================

    function tickTimer() {
      if (manualEnded) {
        if (manualRemainAt != null) {
          els.timer.textContent = formatSeconds(manualRemainAt, timerStuff.format);
        }
        return;
      }
      const snap = calcTimeLeft();
      els.timer.textContent = formatSeconds(snap.remain, timerStuff.format);
      timerStuff.eta = new Date(Date.now() + snap.remain * 1000);
      const totalPlanned =
        parseTimeToSeconds(cfgCache?.startingTime || "00:00:00:00") + Number(dataCache?.general?.addedSecondsTotal || 0);
      const hadStart = Number(dataCache?.general?.startedAt_Unix || 0) > 0;
      const finishedNow = snap.remain === 0 && totalPlanned > 0 && hadStart;
      if (prevRemainSec === null) prevRemainSec = snap.remain;
      if (snap.remain > 0) finishTriggerSent = false;
      if (finishedNow && prevRemainSec > 0) fireSubathonFinishedOnce();
      prevRemainSec = snap.remain;
      setStatusFromState();

      if (!tickTimer._lastBackupSentAt) tickTimer._lastBackupSentAt = new Set();
      const elapsed =
        parseTimeToSeconds(cfgCache?.startingTime || "00:00:00:00") +
        Number(dataCache?.general?.addedSecondsTotal || 0) -
        snap.remain;
      if (elapsed > 0 && Math.floor(elapsed) % 900 === 0 && !tickTimer._lastBackupSentAt.has(elapsed)) {
        tickTimer._lastBackupSentAt.add(elapsed);
        sb.executeCodeTrigger("subathon_backup_signal").catch(() => { });
      }
    }
    // ====================================================
    setInterval(tickTimer, 1000);
    // ====================================================
    function buildFinishedArgs() {
      const d = dataCache || makeDefaultData();
      const tz = getUserTimeZone();
      const e = d.events || {};
      const base = parseTimeToSeconds(cfgCache?.startingTime || "00:00:00:00");
      const add = Number(d?.general?.addedSecondsTotal || 0);
      const startedAt = Number(d?.general?.startedAt_Unix || 0);
      const nowUnix = Math.floor(Date.now() / 1000);
      const endedAt = Number(d?.general?.endedAt_Unix || nowUnix);
      const pauseRanges = Array.isArray(d?.pauses?.ranges) ? d.pauses.ranges : [];
      let pauseTotal = pauseRanges.reduce((a, b) => a + (Number(b) || 0), 0);
      if (d?.pauses?.isPaused && d?.pauses?.pausedSinceUnix) pauseTotal += Math.max(0, nowUnix - Number(d.pauses.pausedSinceUnix));
      const pauseCount = pauseRanges.length + (d?.pauses?.isPaused ? 1 : 0) - 1;
      const elapsed = startedAt > 0 ? Math.max(0, endedAt - startedAt - pauseTotal) : 0;
      const primesubs = Number(e?.primesubs?.count || 0);
      const t1subs = Number(e?.t1subs?.count || 0);
      const t2subs = Number(e?.t2subs?.count || 0);
      const t3subs = Number(e?.t3subs?.count || 0);
      const subs = primesubs + t1subs + t2subs + t3subs;
      const bits = Number(e?.bits?.count || 0);
      const donations = Number(e?.donations?.count || 0);
      const follows = Number(e?.follows?.count || 0);
      const raids = Number(e?.raids?.count || 0);
      const channelPoints = Number(e?.channelpointrewards?.count || 0);
      const loyaltyPoints = Number(e?.loyaltypoints?.count || 0);
      const sAdded_primesubs = Number(e?.primesubs?.totalSecondsAdded || 0);
      const sAdded_t1subs = Number(e?.t1subs?.totalSecondsAdded || 0);
      const sAdded_t2subs = Number(e?.t2subs?.totalSecondsAdded || 0);
      const sAdded_t3subs = Number(e?.t3subs?.totalSecondsAdded || 0);
      const sAdded_bits = Number(e?.bits?.totalSecondsAdded || 0);
      const sAdded_donations = Number(e?.donations?.totalSecondsAdded || 0);
      const sAdded_follows = Number(e?.follows?.totalSecondsAdded || 0);
      const sAdded_channelPoints = Number(e?.channelpointrewards?.totalSecondsAdded || 0);
      const sAdded_raids = Number(e?.raids?.totalSecondsAdded || 0);
      const sAdded_loyaltyPoints = Number(e?.loyaltypoints?.totalSecondsAdded || 0);
      return {
        isActive: !!d?.general?.isActive,
        timezone: tz,
        startedAt_Unix: startedAt || null,
        endedAt_Unix: endedAt || null,
        startedAt_local: startedAt ? formatDateInTZ(startedAt, tz) : null,
        endedAt_local: endedAt ? formatDateInTZ(endedAt, tz) : null,
        baseSeconds: base,
        addedSecondsTotal: add,
        plannedTotalSeconds: base + add,
        elapsedSeconds: elapsed,
        remainingSecondsAtFinish: 0,
        baseFormatted: formatSeconds(base, "hh:mm:ss"),
        addedFormatted: formatSeconds(add, "hh:mm:ss"),
        elapsedFormatted: formatSeconds(elapsed, "hh:mm:ss"),
        plannedTotalFormatted: formatSeconds(base + add, "hh:mm:ss"),
        pauseCount: pauseCount,
        pauseTotalSeconds: pauseTotal,
        pauseTotalFormatted: formatSeconds(pauseTotal, "hh:mm:ss"),
        subs,
        primesubs,
        t1subs,
        t2subs,
        t3subs,
        bits,
        donations,
        follows,
        raids,
        channelPoints,
        loyaltyPoints,
        secondsAdded_primesubs: sAdded_primesubs,
        secondsAdded_t1subs: sAdded_t1subs,
        secondsAdded_t2subs: sAdded_t2subs,
        secondsAdded_t3subs: sAdded_t3subs,
        secondsAdded_bits: sAdded_bits,
        secondsAdded_donations: sAdded_donations,
        secondsAdded_follows: sAdded_follows,
        secondsAdded_channelPoints: sAdded_channelPoints,
        secondsAdded_raids: sAdded_raids,
        secondsAdded_loyaltyPoints: sAdded_loyaltyPoints
      };
    }
    // ====================================================
    async function fireSubathonFinishedOnce() {
      if (finishTriggerSent) return;
      finishTriggerSent = true;
      try {
        const args = buildFinishedArgs();
        await sb.executeCodeTrigger("subathon_finished", args);
      } catch { }
    }
    // ====================================================
    async function fireGoalTrigger(goalName, goalCount, goalType) {
      try {
        await sb.executeCodeTrigger("subathon_goal", {
          goalName: String(goalName || ""),
          goalCount: Number(goalCount || 0),
          goalType: String(goalType || "")
        });
      } catch { }
    }
    // ====================================================
    function showConnectionState(ok) {
      isConnected = !!ok;
      if (ok) {
        connectedOnce = true;
        setStatusFromState();
      } else {
        connectedOnce = false;
        showFooter("Disconnected", "error");
      }
    }
    // ====================================================
    const sb = new StreamerbotClient({
      host: address,
      port,
      password,
      onConnect: async () => {
        showConnectionState(true);
        try {
          const [sRes, dRes] = await Promise.allSettled([sb.getGlobal(SETTINGS_VAR), sb.getGlobal(DATA_VAR)]);
          hasCfg = sRes.status === "fulfilled" && sRes.value && sRes.value.status !== "error" && sRes.value.variable;
          hasData = dRes.status === "fulfilled" && dRes.value && dRes.value.status !== "error" && dRes.value.variable;
          if (hasCfg) applySettings(sRes.value.variable.value);
          else applySettings({});
          if (hasData) applyData(dRes.value.variable.value);
          else applyData(makeDefaultData());
          goalTriggersArmed = true;
          setStatusFromState();
          updateGoalsViewportAuto(goalViewportCount);
        } catch {
          showFooter("Disconnected", "error");
          applySettings({});
          applyData(makeDefaultData());
        }
      },
      onDisconnect: () => {
        showConnectionState(false);
      },
      onError: () => {
        if (!connectedOnce) showFooter("Disconnected", "error");
      }
    });
    setTimeout(() => {
      if (!connectedOnce) showFooter("Disconnected", "error");
    }, 3500);
    sb.on("Misc.GlobalVariableUpdated", msg => {
      const name = msg?.data?.name;
      if (name === SETTINGS_VAR) {
        const newCfg = typeof msg.data.newValue === "string" ? parseJsonOrEmpty(msg.data.newValue) : msg.data.newValue;
        hasCfg = true;
        applySettings(newCfg);
        Array.from(els.goalsInner.querySelectorAll(".goal")).forEach(g => {
          const kind = g.dataset.kind;
          const target = parseFloat(g.dataset.target || "0") || 0;
          const cv = Number(counts[kind] || 0);
          if (cv >= target && target > 0) {
            const key = g.dataset.key || "";
            if (key) firedGoals.add(key);
          }
        });
        setStatusFromState();
        updateGoalsViewportAuto(goalViewportCount);
      } else if (name === DATA_VAR) {
        manualEnded = false;
        manualRemainAt = null;
        manualEndedAt = null;

        const newVal = typeof msg.data.newValue === "string" ? parseJsonOrEmpty(msg.data.newValue) : msg.data.newValue;
        hasData = true;
        applyData(newVal);
        setStatusFromState();
        updateGoalsViewportAuto(goalViewportCount);
      }

      // ====================================================
    });
    window.addEventListener("load", () => {
      updateGoalsViewportAuto(goalViewportCount);
    });
    window.addEventListener("resize", () => {
      updateGoalsViewportAuto(goalViewportCount);
    });
    sb.on("General.Custom", msg => {
      const tag = msg?.data?.data;

      if (tag === "tawmae_subathon_ended_manually") {
        manualEnded = true;
        manualEndedAt = Date.now();
        const snap = calcTimeLeft();
        manualRemainAt = snap.remain;
        showFooter(cfgCache.endedText || "Subathon ended", "ended");
        try {
          const args = buildFinishedArgs();
          sb.executeCodeTrigger("subathon_ended", args);
        } catch { }
        return;
      }

      if (tag === "tawmae_subathon_data_refresh") {
        (async () => {
          try {
            const res = await sb.getGlobal(DATA_VAR);
            if (res && res.status !== "error" && res.variable) {
              hasData = true;
              const val = res.variable.value;
              applyData(val);
              manualEnded = false;
              manualRemainAt = null;
              manualEndedAt = null;
              setStatusFromState();
              updateGoalsViewportAuto(goalViewportCount);
            } else {
              showFooter("Subathon data missing", "warn");
            }
          } catch {
            showFooter("Subathon data refresh failed", "warn");
          }
        })();
      }
    });

    // ====================================================
  </script>
</body>

</html>
