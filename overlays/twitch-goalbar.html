<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>tawmae - TWITCH GOALBAR - v.1.0.1</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Poppins&family=Inter&family=Roboto&family=Bitcount+Ink&family=Open+Sans&family=Lato&family=Oswald&family=SUSE&family=Arimo&family=Ubuntu&family=Nunito&family=Merriweather&family=Playfair+Display&family=Libre+Baskerville&family=Mulish&family=Barlow&family=Inconsolata&family=Bebas+Neue&family=Figtree&family=Saira&family=Josefin+Sans&family=Fjalla+One&family=Bungee&family=Plus+Jakarta+Sans&family=Pacifico&family=Comfortaa&family=Overpass&family=Urbanist&display=swap"
    rel="stylesheet">
  <script src="https://code.iconify.design/iconify-icon/1.0.2/iconify-icon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
  <style>
    :root {
      --edge1: #7f5af0;
      --edge2: #00e5ff;
      --edge3: #22e0a6;
      --text: #eef2ff;
      --muted: #c9cfdd;
      --zoom: 1
    }


    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      font-family: 'Poppins', sans-serif;
      color: var(--text);
      overflow: hidden
    }

    .wrap {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center
    }

    .zoom-stage {
      width: 92vw;
      display: flex;
      align-items: center;
      justify-content: center
    }

    .zoom-stage .goal {
      transform: scale(var(--zoom));
      transform-origin: center center
    }


    .goal {
      position: relative;
      width: calc(100% / var(--zoom));
      padding: 10px 10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, .14);
      box-shadow: 0 8px 26px rgba(0, 0, 0, .45), inset 0 0 0 1px rgba(255, 255, 255, .05);
      overflow: hidden
    }

    .goal-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      justify-content: center
    }

    .goal-header iconify-icon {
      font-size: 2.2rem
    }

    .goal-title {
      font-size: 1.9rem;
      font-weight: 900;
      letter-spacing: .4px
    }

    .progress-wrapper {
      position: relative;
      margin-top: 2px
    }

    .progress-bar {
      position: relative;
      width: 100%;
      height: 28px;
      border-radius: 9px;
      background: rgba(255, 255, 255, .09);
      border: 1px solid rgba(255, 255, 255, .14);
      overflow: hidden
    }

    .progress-fill {
      position: absolute;
      inset: 0 auto 0 0;
      width: 0%;
      border-radius: 9px;
      background: linear-gradient(90deg, var(--edge1), var(--edge2), var(--edge3))
    }

    .progress-text {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-weight: 800;
      font-size: 1.05rem;
      stroke: black;
      text-shadow: 0 1px 1px rgba(0, 0, 0, .5)
    }

    .progress-row {
      display: flex;
      align-items: center;
      gap: 15px
    }

    .current-value,
    .goal-value {
      font-size: 1.35rem;
      font-weight: 900;
      min-width: 50px;
      text-align: center
    }

    .current-value {
      color: #fff
    }

    .goal-value {
      color: var(--muted)
    }

    .progress-bar {
      flex: 1;
      height: 28px;
      border-radius: 9px;
      background: rgba(255, 255, 255, .09);
      border: 1px solid rgba(255, 255, 255, .14);
      overflow: hidden;
      position: relative
    }

    .change-indicator {
      position: absolute;
      top: 10px;
      right: 12px;
      font-size: 1.1rem;
      font-weight: 900;
      opacity: 0;
      white-space: nowrap;
      color: #22e0a6;
      pointer-events: none;
      z-index: 10
    }

    .completed-badge {
      position: absolute;
      top: 10px;
      right: 12px;
      display: none;
      align-items: center;
      gap: 6px;
      font-size: .95rem;
      font-weight: 900;
      color: #ffd54a;
      pointer-events: none;
      z-index: 11
    }

    .overlay {
      position: fixed;
      z-index: 9999;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      pointer-events: none
    }

    .badge {
      display: none;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 12px;
      font-weight: 900;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, .18);
      box-shadow: 0 8px 24px rgba(0, 0, 0, .35)
    }

    .badge--error {
      background: rgba(255, 92, 122, .92);
      color: #fff
    }

    .badge--warn {
      background: rgba(255, 209, 102, .95);
      color: #341f00
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="zoom-stage">
      <div class="goal">
        <div class="goal-header">
          <iconify-icon icon="ri:poker-diamonds-line"></iconify-icon>
          <div class="goal-title">Bits</div>
        </div>
        <div class="progress-wrapper">
          <div class="progress-row">
            <div class="current-value">0</div>
            <div class="progress-bar">
              <div class="progress-fill"><span class="progress-text">0%</span></div>
            </div>
            <div class="goal-value">0</div>
          </div>
        </div>
        <div class="change-indicator"></div>
        <div class="completed-badge"><iconify-icon
            icon="gridicons:checkmark-circle"></iconify-icon><span>COMPLETED</span>
        </div>
      </div>
    </div>
  </div>
  <div class="overlay">
    <div id="badge-disconnected" class="badge badge--error">Disconnected</div>
    <div id="badge-actions" class="badge badge--warn">Please import the Streamer.bot actions first</div>
    <div id="badge-settings" class="badge badge--warn">Please initialize the settings UI first</div>
  </div>
  <script>
    const names = ['Follows', 'Subs', 'Bits', 'Donations']
    let events = [], idx = 0, rotationIntervalId, lastCounts = [], lastPercents = []
    const iconEl = document.querySelector('iconify-icon')
    const titleEl = document.querySelector('.goal-title')
    const fillEl = document.querySelector('.progress-fill')
    const textEl = document.querySelector('.progress-text')
    const changeEl = document.querySelector('.change-indicator')
    const completedEl = document.querySelector('.completed-badge')
    const currentValEl = document.querySelector('.current-value')
    const goalValEl = document.querySelector('.goal-value')
    const goalBox = document.querySelector('.goal')
    const progressBar = document.querySelector('.progress-bar')
    const badgeDisconnected = document.getElementById('badge-disconnected')
    const badgeActions = document.getElementById('badge-actions')
    const badgeSettings = document.getElementById('badge-settings')
    const fontMap = { "Poppins": "Poppins", "Inter": "Inter", "Roboto": "Roboto", "Bitcount Ink": "Bitcount Ink", "Open Sans": "Open Sans", "Lato": "Lato", "Oswald": "Oswald", "SUSE": "SUSE", "Arimo": "Arimo", "Ubuntu": "Ubuntu", "Nunito": "Nunito", "Merriweather": "Merriweather", "Playfair Display": "Playfair Display", "Libre Baskelville": "Libre Baskerville", "Mulish": "Mulish", "Barlow": "Barlow", "Inconsolata": "Inconsolata", "Bebas Neue": "Bebas Neue", "Figtree": "Figtree", "Saira": "Saira", "Josefin Sans": "Josefin Sans", "Fjalla One": "Fjalla One", "Bungee": "Bungee", "Plus Jakarta Sans": "Plus Jakarta Sans", "Pacifico": "Pacifico", "Comfortaa": "Comfortaa", "Overpass": "Overpass", "Urbanist": "Urbanist" }
    const animations = [el => anime({ targets: el, scale: [0, 1], opacity: [0, 1], duration: 450, easing: 'easeOutBack' }), el => anime({ targets: el, scale: [0, 1.08, 1], opacity: [0, 1], duration: 550, easing: 'easeOutElastic(1,.6)' }), el => anime({ targets: el, translateY: [-10, 0], opacity: [0, 1], duration: 420, easing: 'easeOutBounce' })]
    const currencySymbols = { "USD": "$", "EUR": "€", "GBP": "£", "JPY": "¥", "CNY": "¥", "AUD": "A$", "CAD": "C$", "CHF": "CHF", "SEK": "kr", "NZD": "NZ$" }
    let currentCurrency = "USD"
    function clamp(n, min, max) { return Math.min(Math.max(n, min), max) }
    function hexToRgb(hex) { let h = String(hex || '').replace('#', '').trim(); if (h.length === 3) h = h.split('').map(x => x + x).join(''); if (!/^[0-9a-fA-F]{6}$/.test(h)) h = '07070b'; const num = parseInt(h, 16); return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 } }
    function mix(a, b, t) { return Math.round(a + (b - a) * t) }
    function rgba(r, g, b, a) { return `rgba(${r},${g},${b},${a})` }
    function computeGradient(baseHex, transparency) { const base = hexToRgb(baseHex); const alpha = clamp((Number(transparency) || 0) / 100, 0, 1); const lightR = mix(base.r, 255, 0.12), lightG = mix(base.g, 255, 0.12), lightB = mix(base.b, 255, 0.12); const darkR = mix(base.r, 0, 0.18), darkG = mix(base.g, 0, 0.18), darkB = mix(base.b, 0, 0.18); const c1 = rgba(lightR, lightG, lightB, alpha), c2 = rgba(base.r, base.g, base.b, alpha), c3 = rgba(darkR, darkG, darkB, alpha); return `linear-gradient(180deg,${c1} 0%,${c2} 50%,${c3} 100%)` }
    function getIncludedArray(cfg) { try { if (Array.isArray(cfg.includedEvents)) return cfg.includedEvents.map(Boolean); if (typeof cfg.includedEvents === 'string') { const arr = JSON.parse(cfg.includedEvents); if (Array.isArray(arr)) return arr.map(Boolean) } } catch (e) { } return [cfg.include_Follows, cfg.include_Subs, cfg.include_Bits, cfg.include_Donations].map(Boolean) }
    function parseConfig(cfg) {
      const included = getIncludedArray(cfg)
      const evNames = names.filter((_, i) => included[i])
      const evs = evNames.map(n => { const max = Number(cfg['goal_amount_' + n]); const displayMax = (n === 'Donations') ? `${max.toFixed(2)}` : `${max}`; return { type: n, icon: cfg['icon_' + n], title: cfg['title_' + n], max, displayMax, color: cfg['bar_color_' + n] } })
      const counts = evNames.map(n => { const current = Number(cfg['currentCount_' + n]); const displayCurrent = (n === 'Donations') ? `${current.toFixed(2)}` : `${current}`; return { current, displayCurrent } })
      const bg = cfg['bar_color_Background'] || '#07070b'
      const bgT = cfg['background_Transparency'] ?? 100
      const roundedBg = cfg['rounded_Corners_Background'] === true
      const roundedBar = cfg['rounded_Corners_Bar'] === true
      const fontKey = cfg['bar_Font'] || 'Poppins'
      const font = fontMap[fontKey] || 'Poppins'
      const fontColor = cfg['bar_font_Color'] || '#eef2ff'
      const currency = cfg['bar_Currency'] || 'USD'
      const zoom = Number(cfg['zoomLevel']) || 1
      return { evs, counts, duration: cfg['rotaton_duration_milliseconds'], bg, bgT, roundedBg, roundedBar, font, fontColor, currency, zoom }
    }
    function applyBackground(bg, bgT) { goalBox.style.background = computeGradient(bg, bgT) }
    function initialize(evs, counts, duration, bg, bgT, roundedBg, roundedBar, font, fontColor, currency, zoom) {
      currentCurrency = currency
      events = evs.map((e, i) => ({ ...e, ...counts[i] }))
      lastCounts = events.map(e => e.current)
      lastPercents = events.map(e => Math.min(100, Math.round((e.current / e.max) * 100)))
      document.documentElement.style.setProperty('--zoom', String(zoom || 1))
      applyBackground(bg, bgT)
      goalBox.style.borderRadius = roundedBg ? '14px' : '0'
      progressBar.style.borderRadius = roundedBar ? '9px' : '0'
      fillEl.style.borderRadius = roundedBar ? '9px' : '0'
        ;[goalBox, titleEl, textEl, currentValEl, goalValEl, iconEl].forEach(t => { t.style.fontFamily = `'${font}', sans-serif`; t.style.color = fontColor })
      idx = 0
      showEvent(0)
      if (rotationIntervalId) clearInterval(rotationIntervalId)
      if (events.length > 1) startCycle(duration || 6000)
    }

    function animateCount(el, fromVal, toVal, isDonation, duration) {
      let obj = { val: fromVal }
      const symbol = isDonation ? (currencySymbols[currentCurrency] || currentCurrency) : ""
      gsap.to(obj, { val: toVal, duration: duration, ease: 'power2.out', onUpdate: () => { el.textContent = isDonation ? `${obj.val.toFixed(2)} ${symbol}` : `${Math.round(obj.val)}` } })
    }
    function animatePercent(fromP, toP, duration) { let obj = { val: fromP }; gsap.to(obj, { val: toP, duration: duration, ease: 'power2.out', onUpdate: () => { textEl.textContent = `${Math.round(obj.val)}%` } }) }
    function updateCompletedVisibility(pct) {
      if (pct >= 100) {
        completedEl.style.display = 'inline-flex'
        changeEl.style.opacity = 0
      } else {
        completedEl.style.display = 'none'
      }
    }
    function showEvent(i) {
      const e = events[i]
      iconEl.setAttribute('icon', e.icon)
      titleEl.textContent = e.title
      const isDonation = e.type === "Donations"
      const symbol = isDonation ? (currencySymbols[currentCurrency] || currentCurrency) : ""
      currentValEl.textContent = isDonation ? `0.00 ${symbol}` : "0"
      goalValEl.textContent = isDonation ? `${e.displayMax} ${symbol}` : e.displayMax
      fillEl.style.background = e.color ? e.color : 'linear-gradient(90deg,#7f5af0,#00e5ff,#22e0a6)'
      fillEl.style.width = '0%'
      textEl.textContent = '0%'
      completedEl.style.display = 'none'
      const a = animations[Math.floor(Math.random() * animations.length)]
      a(iconEl)
      gsap.fromTo(titleEl, { y: 4, opacity: 0 }, { y: 0, opacity: 1, duration: .4, ease: 'power3.out' })
      animateFill(i, true, true)
    }
    function animateFill(i, withCountUp = false, fromZero = false) {
      const e = events[i]
      let target = Math.min(100, (e.current / e.max) * 100)
      const startPercent = fromZero ? 0 : lastPercents[i] || 0
      const d = 1
      gsap.to(fillEl, { width: `${target}%`, duration: d, ease: 'power2.out' })
      animatePercent(startPercent, target, d)
      if (withCountUp) {
        const isDonation = e.type === "Donations"
        const fromVal = fromZero ? 0 : lastCounts[i] || 0
        animateCount(currentValEl, fromVal, e.current, isDonation, d)
      }
      lastPercents[i] = Math.round(target)
      updateCompletedVisibility(target)
    }
    function startCycle(duration) { if (rotationIntervalId) clearInterval(rotationIntervalId); rotationIntervalId = setInterval(() => { const next = (idx + 1) % events.length; idx = next; showEvent(idx) }, duration) }
    function showChange(delta) {
      if (delta <= 0) return
      if (completedEl.style.display === 'inline-flex') return
      const isDonation = events[idx].type === "Donations"
      const symbol = isDonation ? (currencySymbols[currentCurrency] || currentCurrency) : ""
      const formatted = isDonation ? delta.toFixed(2) : delta
      changeEl.textContent = `+${formatted}${symbol ? " " + symbol : ""}`
      gsap.fromTo(changeEl, { x: 24, opacity: 0 }, { x: 0, opacity: 1, duration: .3, ease: 'power2.out', onComplete: () => gsap.to(changeEl, { x: 24, opacity: 0, duration: .35, delay: 1 }) })
    }
    function updateCountsOnly(newCfg) {
      const { evs, counts, bg, bgT, roundedBg, roundedBar, font, fontColor, currency, zoom } = parseConfig(newCfg)
      currentCurrency = currency
      document.documentElement.style.setProperty('--zoom', String(zoom || 1))
      applyBackground(bg, bgT)
      goalBox.style.borderRadius = roundedBg ? '14px' : '0'
      progressBar.style.borderRadius = roundedBar ? '9px' : '0'
      fillEl.style.borderRadius = roundedBar ? '9px' : '0'
        ;[goalBox, titleEl, textEl, currentValEl, goalValEl, iconEl].forEach(t => { t.style.fontFamily = `'${font}', sans-serif`; t.style.color = fontColor })
      evs.forEach((e, i) => { const oldMax = events[i]?.max; events[i].max = e.max; events[i].displayMax = e.displayMax; if (i === idx && oldMax !== e.max) { const symbol = e.type === "Donations" ? (currencySymbols[currentCurrency] || currentCurrency) : ""; goalValEl.textContent = e.type === "Donations" ? `${e.displayMax} ${symbol}` : e.displayMax; animateFill(i, true, false) } })
      counts.forEach((c, i) => { const prev = lastCounts[i] ?? 0; const diff = c.current - prev; events[i].current = c.current; events[i].displayCurrent = c.displayCurrent; if (i === idx && diff !== 0) { animateFill(i, true, false); showChange(diff) } lastCounts[i] = c.current; lastPercents[i] = Math.min(100, Math.round((events[i].current / events[i].max) * 100)) })
      updateCompletedVisibility(lastPercents[idx] || 0)
    }

    function getConnParams() { const sp = new URLSearchParams(location.search); let host = '127.0.0.1', port = 8080; let password = sp.get('password') || undefined; for (const [k, v] of sp.entries()) { const lk = k.toLowerCase(); if (lk === 'address') host = v; if (lk === 'port') port = Number(v) || 8080 } return { host, port, password } }
    function showBadge(el, show) { el.style.display = show ? 'flex' : 'none' }
    const { host, port, password } = getConnParams()
    const client = new StreamerbotClient({
      host, port, endpoint: '/', password,
      subscribe: { Misc: ['GlobalVariableUpdated'] },
      onConnect: async (info) => {
        showBadge(badgeDisconnected, false)
        let actionsOk = false
        try { const res = await client.getActions(); if (res && res.status === 'ok') { actionsOk = res.actions.some(a => a.id === 'b7bf5290-6372-4a17-8db9-66f0e1719711') } } catch (e) { }
        showBadge(badgeActions, !actionsOk)
        try {
          const g = await client.getGlobal('tawmae_Settings_TWITCH GOALBAR')
          if (!g || g.status === 'error') { showBadge(badgeSettings, true); return }
          showBadge(badgeSettings, false)
          const cfg = typeof g.variable.value === 'string' ? JSON.parse(g.variable.value) : g.variable.value
          const { evs, counts, duration, bg, bgT, roundedBg, roundedBar, font, fontColor, currency, zoom } = parseConfig(cfg)
          initialize(evs, counts, duration, bg, bgT, roundedBg, roundedBar, font, fontColor, currency, zoom)

        } catch (err) { showBadge(badgeSettings, true) }
      },
      onDisconnect: () => { showBadge(badgeDisconnected, true) },
      onError: () => { showBadge(badgeDisconnected, true) }
    })
    client.on('Misc.GlobalVariableUpdated', data => {
      if (data.data.name !== 'tawmae_Settings_TWITCH GOALBAR') return
      const oldCfg = JSON.parse(data.data.oldValue)
      const newCfg = JSON.parse(data.data.newValue)
      const designChange = (() => {
        if (oldCfg.rotaton_duration_milliseconds !== newCfg.rotaton_duration_milliseconds) return true
        if (oldCfg.bar_color_Background !== newCfg.bar_color_Background) return true
        if (oldCfg.background_Transparency !== newCfg.background_Transparency) return true
        if (oldCfg.rounded_Corners_Background !== newCfg.rounded_Corners_Background) return true
        if (oldCfg.rounded_Corners_Bar !== newCfg.rounded_Corners_Bar) return true
        if (oldCfg.bar_Font !== newCfg.bar_Font) return true
        if (oldCfg.bar_font_Color !== newCfg.bar_font_Color) return true
        if (String(oldCfg.includedEvents) !== String(newCfg.includedEvents)) return true
        for (let n of names) { if (oldCfg['icon_' + n] !== newCfg['icon_' + n]) return true; if (oldCfg['title_' + n] !== newCfg['title_' + n]) return true; if (oldCfg['bar_color_' + n] !== newCfg['bar_color_' + n]) return true }
        return false
      })()
      if (designChange) {
        const { evs, counts, duration, bg, bgT, roundedBg, roundedBar, font, fontColor, currency, zoom } = parseConfig(newCfg)
        initialize(evs, counts, duration, bg, bgT, roundedBg, roundedBar, font, fontColor, currency, zoom)

      } else {
        updateCountsOnly(newCfg)
      }
    })
  </script>
</body>

</html>
