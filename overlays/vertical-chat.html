<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>VERTICAL CHAT - v.1.0.7 - tawmae</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800;900&display=swap" rel="stylesheet">
  <script src="https://code.iconify.design/2/2.2.1/iconify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
      font-family: 'Poppins', sans-serif;
      font-size: 16px;
      color: #ffffff;
      text-shadow: none;
    }

    body.dropshadow * {
      text-shadow: 1.3px 1.3px 1.3px black;
    }

    body.big-dropshadow * {
      text-shadow: 0.8px 0.8px black, 0.9px 0.9px black, 1px 1px black, 1.1px 1.1px black, 1.2px 1.2px black, 1.3px 1.3px black, 1.4px 1.4px black, 1.5px 1.5px black;
    }

    body.dropshadow .iconify,
    body.big-dropshadow .iconify {
      filter: drop-shadow(1.3px 1.3px 1.3px black);
    }

    body.big-dropshadow .iconify {
      filter: drop-shadow(0.8px 0.8px black, 0.9px 0.9px black, 1px 1px black, 1.1px 1.1px black, 1.2px 1.2px black, 1.3px 1.3px black, 1.4px 1.4px black, 1.5px 1.5px black);
    }

    #background-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    #chat-container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: transparent;
      z-index: 1;
    }

    #messages {
      flex: 1;
      padding: 0.625em;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      justify-content: flex-end;
    }

    #message-list {
      display: flex;
      flex-direction: column;
    }

    .message,
    .announcement,
    .subscription {
      margin-bottom: 0.625em;
      display: flex;
      flex-direction: column;
      animation: slide-in-up 0.5s forwards;
      color: #ffffff;
    }

    .message,
    .announcement,
    .subscription {
      transition: opacity 0.5s ease;
    }

    .fade-out {
      opacity: 0 !important;
    }

    .message-header,
    .announcement-header,
    .subscription-header {
      display: flex;
      align-items: center;
      margin-bottom: 0.3125em;
    }

    .avatar {
      height: 2.5em;
      width: 2.5em;
      border-radius: 50%;
      margin-right: 0.3125em;
      flex-shrink: 0;
    }

    .shared-chat-icon {
      height: 1em;
      width: 1em;
      border-radius: 50%;
      margin-left: 0.3125em;
    }

    .badges img {
      height: 1em;
      width: 1em;
      margin-right: 0.125em;
      margin-top: 0.375em;
    }

    .username {
      font-weight: 700;
      margin-right: 0.3125em;
      margin-left: 0.3125em;
      display: inline-flex;
      align-items: center;
    }

    .pronouns-box {
      font-size: 0.625em;
      color: #cccccc;
      background: #333333;
      padding: 0 0.1875em;
      border-radius: 0.1875em;
      margin-left: 0.3125em;
      display: inline-flex;
      align-items: center;
    }

    .new-chatter {
      font-size: 0.75em;
      color: #00FFFF;
      font-weight: 600;
      margin-left: 0.3125em;
      display: inline-flex;
      align-items: center;
    }

    .message-text {
      word-wrap: break-word;
      margin: 0.0625em 0 0.3125em 0;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      width: 100%;
      margin-top: 0;
    }

    .announcement-text,
    .subscription-text {
      word-wrap: break-word;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      width: 100%;
      margin-top: 0;
    }

    .message-text img,
    .announcement-text img,
    .subscription-text img {
      height: 1.25em;
      width: auto;
      object-fit: contain;
      vertical-align: middle;
      margin-left: 0.25em;
      margin-right: 0.25em;
    }

    .gigantified-emote {
      width: 6.25em !important;
      height: 6.25em !important;
      object-fit: contain;
      vertical-align: middle;
      margin-left: 0.25em;
      margin-right: 0.25em;
    }

    .reply-preview {
      padding: 0.0625em 0.1875em;
      margin: 0.0625em 0 0.3125em 0;
      font-size: 0.75em;
      color: #dddddd;
      max-width: 100%;
      word-wrap: break-word;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-style: italic;
      display: flex;
      align-items: center;
    }

    .reply-preview img {
      height: 0.75em;
      width: auto;
      object-fit: contain;
      vertical-align: middle;
      margin-left: 0.125em;
      margin-right: 0.125em;
    }

    .announcement .icon,
    .subscription .icon {
      height: 1em;
      width: 1em;
      margin-right: 0.3125em;
      flex-shrink: 0;
      margin-bottom: 0.3125em;
    }

    .announcement .icon svg,
    .subscription .icon svg {
      width: 100%;
      height: 100%;
      fill: currentColor;
    }

    .announcement-title,
    .subscription-title {
      font-weight: 900;
      font-size: 1em;
    }

    #status-indicator {
      position: fixed;
      top: 0.625em;
      right: 0.625em;
      background: red;
      color: #fff;
      padding: 0.3125em 0.625em;
      border-radius: 0.25em;
      font-size: 0.875em;
      z-index: 9999;
      transition: background 0.5s, opacity 0.5s;
    }

    .hidden {
      opacity: 0;
      pointer-events: none;
    }

    .message-text img:not(.gigantified-emote),
    .announcement-text img:not(.gigantified-emote),
    .subscription-text img:not(.gigantified-emote) {
      height: 1.8em;
    }
  </style>
</head>

<body>
  <div id="status-indicator">DISCONNECTED</div>
  <div id="chat-container">
    <div id="messages">
      <div id="message-list"></div>
    </div>
  </div>
  <script>
    (function () {
      const MAX_CACHE_SIZE = 1000;
      function cacheSet(map, key, value) {
        if (map.size >= MAX_CACHE_SIZE) {
          map.delete(map.keys().next().value);
        }
        map.set(key, value);
      }
      const params = new URLSearchParams(window.location.search);
      const caseInsensitiveParams = {};
      for (const [key, value] of params.entries()) {
        caseInsensitiveParams[key.toLowerCase()] = value;
      }
      function getParam(key, defaultValue = null) {
        return caseInsensitiveParams[key.toLowerCase()] || defaultValue;
      }
      const font = getParam('font', 'Poppins');
      const fontsize = getParam('fontsize', '16px');
      const dropshadow = getParam('dropshadow', 'true') !== 'false';
      const excludedAccounts = getParam('excludeaccounts', '')
        .split(/[,+\s]+/)
        .map(acc => acc.trim().toLowerCase())
        .filter(acc => acc);
      const excludeCommands = getParam('excludecommands', 'false') === 'true';
      const excludeEventsParam = getParam('excludeevents', '')
        .split(/[,+\s]+/)
        .map(e => e.trim().toLowerCase())
        .filter(e => e);
      const address = getParam('address', '127.0.0.1');
      const port = getParam('port', '8080');
      const backgroundEnabled = getParam('background', 'false') === 'true';
      const backgroundOpacity = getParam('backgroundopacity', '90');
      const backgroundColor = getParam('backgroundcolor', 'black');
      const hidePronouns   = getParam('hidepronouns', 'false') === 'true';
      const hideTimestamp = getParam('hidetimestamp', 'true') !== 'false';
      const hideAvatars    = getParam('hideavatars',  'false') === 'true';
      const minRewardCost = parseInt(getParam('minrewardcost', '0'), 10);
      const hideAfterSeconds = parseInt(getParam('hideafter', '0'), 10) || null;
      const hideIcons = getParam('hideicons', 'false') === 'true';
      const hideBadges = getParam('hidebadges', 'false') === 'true';
      const bigDropshadow = getParam('bigdropshadow', 'false') === 'true';
      const backgroundStyle = (getParam('backgroundstyle') || '').toLowerCase();

      document.body.style.fontFamily = `${font}, sans-serif`;
      document.body.style.fontSize = fontsize;
      if (dropshadow) {
        document.body.classList.add(bigDropshadow ? 'big-dropshadow' : 'dropshadow');
      }
      document.body.style.backgroundColor = 'transparent';

      const chatContainer = document.getElementById('chat-container');
      const messagesContainer = document.getElementById('messages');
      const messageList = document.getElementById('message-list');
      const statusIndicator = document.getElementById('status-indicator');
      chatContainer.style.position = 'absolute';
      chatContainer.style.top = '0';
      chatContainer.style.textAlign = 'left';
      messageList.style.alignItems = 'flex-start';


      function parseColorToRGBA(col, alpha) {
        const temp = document.createElement('div');
        temp.style.color = col;
        document.body.appendChild(temp);
        const computed = window.getComputedStyle(temp).color;
        document.body.removeChild(temp);
        if (computed.startsWith('rgba')) {
          return computed.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*(.*)\)/, `rgba($1,$2,$3,${alpha})`);
        } else if (computed.startsWith('rgb')) {
          return computed.replace(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/, `rgba($1,$2,$3,${alpha})`);
        }
        return col;
      }

      if (backgroundEnabled && ['cards', 'cardsrounded'].includes(backgroundStyle)) {
        const op = Number(backgroundOpacity) / 100;
        const rgba = parseColorToRGBA(backgroundColor, op);
        const styleEl = document.createElement('style');
        styleEl.innerHTML = `
          .message, .announcement, .subscription {
            background-color: ${rgba} !important;
            padding: 0.5em;
            margin: 0.5em 0;
          }
        `;
        if (backgroundStyle === 'cardsrounded') {
          styleEl.innerHTML += `
            .message, .announcement, .subscription {
              border-radius: 0.5em;
            }
          `;
        }
        document.head.appendChild(styleEl);
      } else if (backgroundEnabled) {
        const overlay = document.createElement('div');
        overlay.id = 'background-overlay';
        overlay.style.backgroundColor = backgroundColor;
        overlay.style.opacity = Number(backgroundOpacity) / 100;
        document.body.insertBefore(overlay, document.body.firstChild);
      }

      const messagesMap = new Map();
      const userMessagesMap = new Map();
      const avatarCache = new Map();
      const sharedChatAvatarCache = new Map();
      const replyPreviewsMap = new Map();
      const msgEmotesMap = new Map();
      const userColorCache = new Map();
      const pronounCache = new Map();
      const pendingGigantify = new Map();






      async function getPronouns(login) {
        if (pronounCache.has(login)) return pronounCache.get(login);
        try {
          const resp = await client.getUserPronouns('twitch', login);
          if (resp.status === 'ok' && resp.pronoun?.userFound) {
            const p = resp.pronoun.pronouns.replace(/^\(|\)$/g, '');
            pronounCache.set(login, p);
            return p;
          }
        } catch { }
        pronounCache.set(login, null);
        return null;
      }

      function updateExistingGigantify(key, emote) {
        userMessagesMap.forEach((ids, uid) => {
          ids.forEach(id => {
            const el = messagesMap.get(id);
            if (el && el.dataset.userName === key.split('|')[0].toLowerCase() && el.dataset.raw === key.split('|')[1]) {
              el.querySelectorAll('img').forEach(img => {
                if (img.alt === emote.name) img.classList.add('gigantified-emote');
              });
            }
          });
        });
      }

      function addChatMessage(m, u, e, isShared, sharedData) {
        const { msgId, displayName, color, badges, message, parts, isReply, reply, firstMessage } = m;
        const user = (u.username || u.login || u.name || '').toLowerCase();
        if (!user || excludedAccounts.includes(user)) return;

        if (excludeCommands && message.startsWith('!')) return;

        const el = document.createElement('div');
        el.classList.add('message');
        el.dataset.msgId = msgId;
        el.dataset.raw = message;
        el.dataset.userName = user;

        const header = document.createElement('div');
        header.classList.add('message-header');

        if (!hideAvatars) {
          const avatar = document.createElement('img');
          avatar.classList.add('avatar');
          if (avatarCache.has(user)) {
            avatar.src = avatarCache.get(user);
          } else {
            fetch(`https://decapi.me/twitch/avatar/${user}`)
              .then(r => r.text())
              .then(u => { avatar.src = u; cacheSet(avatarCache, user, u); })
              .catch(() => avatar.src = '');
          }
          header.appendChild(avatar);
        }

        if (!hideBadges && Array.isArray(badges)) {
          const bc = document.createElement('div');
          bc.classList.add('badges');
          badges.forEach(b => {
            const bi = document.createElement('img');
            bi.src = b.imageUrl;
            bi.alt = b.name;
            bc.appendChild(bi);
          });
          header.appendChild(bc);
        }

        const uname = document.createElement('span');
        uname.classList.add('username');
        uname.textContent = displayName;
        uname.style.color = color || '#fff';
        header.appendChild(uname);

        if (!hidePronouns || !hideTimestamp) {
         if (!hidePronouns) {
            getPronouns(user).then(p => {
              if (p) {
                const pn = document.createElement('span');
                pn.classList.add('pronouns-box');
                pn.textContent = p;
                header.appendChild(pn);
              }
              if (!hideTimestamp) {
                const ts = document.createElement('span');
                ts.classList.add('pronouns-box');
                ts.textContent = new Date().toLocaleTimeString(navigator.language, { hour: '2-digit', minute: '2-digit' });
                header.appendChild(ts);
              }
            });
          } else {
            const ts = document.createElement('span');
            ts.classList.add('pronouns-box');
            ts.textContent = new Date().toLocaleTimeString(navigator.language, { hour: '2-digit', minute: '2-digit' });
            header.appendChild(ts);
          }
        }

        el.appendChild(header);

        if (color) userColorCache.set(u.userId, color);

        const textContainer = document.createElement('div');
        textContainer.classList.add('message-text');

        if (Array.isArray(parts)) {
          parts.forEach(pt => {
            if (pt.type === 'text') {
              textContainer.appendChild(document.createTextNode(pt.text));
            } else {
              const img = document.createElement('img');
              img.src = pt.imageUrl;
              img.alt = pt.text;
              textContainer.appendChild(img);
            }
          });
        } else {
          let txt = message || '';
          let last = 0;
          (e || []).sort((a, b) => a.startIndex - b.startIndex).forEach(emote => {
            if (emote.startIndex > last) {
              textContainer.appendChild(document.createTextNode(txt.slice(last, emote.startIndex)));
            }
            const img = document.createElement('img');
            img.src = emote.imageUrl;
            img.alt = emote.name;
            textContainer.appendChild(img);
            last = emote.endIndex + 1;
          });
          if (last < txt.length) {
            textContainer.appendChild(document.createTextNode(txt.slice(last)));
          }
        }

        el.appendChild(textContainer);
        messageList.appendChild(el);
        messagesMap.set(msgId, el);

        scheduleHide(el);
      }

      function handleAutomaticRewardRedemption(d) {
        if (d.reward_type === 'gigantify_an_emote') {
          const key = d.user_name + '|' + d.message_text;
          pendingGigantify.set(key, d.gigantified_emote);
          updateExistingGigantify(key, d.gigantified_emote);
        }
      }

      function handleAnnouncement(d) {
        const colorMap = { blue: "#26b1e1", green: "#13d599", orange: "#f5c212", purple: "#a04cfc" };
        const hexColor = colorMap[d.announcementColor.toLowerCase()] || "#FF43D1";
        const el = createSubscriptionElement('ANNOUNCEMENT', hexColor, 'ri:megaphone-line');
        el.dataset.msgId = d.messageId;
        const at = document.createElement('div');
        at.classList.add('subscription-text');
        const announcementContent = replaceEmotesInText(d.text, []);
        if (announcementContent instanceof DocumentFragment) at.appendChild(announcementContent);
        else at.textContent = announcementContent.textContent;
        el.appendChild(at);
        messageList.appendChild(el);
        messagesMap.set(d.messageId, el);
        scheduleHide(el);
      }

      function handleSubscription(d) {
        const actualLogin = d.user.login.toLowerCase();
        let shownName = d.user.name;
        if (shownName.toLowerCase() !== actualLogin) shownName += ` (${actualLogin})`;
        const tier = d.is_prime ? 'Prime' : `Tier ${Math.floor(parseInt(d.sub_tier, 10) / 1000)}`;
        const el = createSubscriptionElement('SUBSCRIPTION', '#FFD700', 'material-symbols:kid-star-outline-sharp');
        el.dataset.msgId = d.messageId;
        const tx = document.createElement('div');
        tx.classList.add('subscription-text');
        tx.textContent = `${shownName} subscribed with a ${tier} Sub!`;
        el.appendChild(tx);
        messageList.appendChild(el);
        messagesMap.set(d.messageId, el);
        scheduleHide(el);
      }

      function handleReSubscription(d) {
        const actualLogin = d.user.login.toLowerCase();
        let shownName = d.user.name;
        if (shownName.toLowerCase() !== actualLogin) shownName += ` (${actualLogin})`;
        const tier = d.isPrime ? 'Prime' : `Tier ${Math.floor(parseInt(d.subTier, 10) / 1000)}`;
        const el = createSubscriptionElement('RESUBSCRIPTION', '#FFD700', 'material-symbols:kid-star-outline-sharp');
        el.dataset.msgId = d.messageId;
        const tx = document.createElement('div');
        tx.classList.add('subscription-text');
        tx.textContent = `${shownName} resubscribed with a ${tier} sub for the ${d.cumulativeMonths}. month!`;
        if (d.text && d.text.trim()) {
          tx.appendChild(document.createElement('br'));
          tx.appendChild(document.createTextNode('↪  «' + d.text + '»'));
        }
        el.appendChild(tx);
        messageList.appendChild(el);
        messagesMap.set(d.messageId, el);
        scheduleHide(el);
      }

      function handleGiftSubscription(d) {
        const giver = d.user.name.toLowerCase() !== d.user.login.toLowerCase()
          ? `${d.user.name} (${d.user.login.toLowerCase()})`
          : d.user.name;
        const recv = d.recipient.name.toLowerCase() !== d.recipient.login.toLowerCase()
          ? `${d.recipient.name} (${d.recipient.login.toLowerCase()})`
          : d.recipient.name;
        const tier = `Tier ${Math.floor(parseInt(d.subTier, 10) / 1000)}`;
        const el = createSubscriptionElement('GIFT SUBSCRIPTION', '#FFD700', 'iconamoon:gift-light');
        el.dataset.msgId = d.messageId;
        const tx = document.createElement('div');
        tx.classList.add('subscription-text');
        tx.textContent = `${giver} gifted a ${tier} sub to ${recv}!`;
        el.appendChild(tx);
        messageList.appendChild(el);
        messagesMap.set(d.messageId, el);
        scheduleHide(el);
      }

      function handleGiftBombSubscription(d) {
        const giver = d.user.name.toLowerCase() !== d.user.login.toLowerCase()
          ? `${d.user.name} (${d.user.login.toLowerCase()})`
          : d.user.name;
        const count = d.total.name;
        const tier = `Tier ${Math.floor(parseInt(d.sub_tier, 10) / 1000)}`;
        const el = createSubscriptionElement('GIFT BOMB', '#FFD700', 'iconamoon:gift-light');
        el.dataset.msgId = d.messageId;
        const tx = document.createElement('div');
        tx.classList.add('subscription-text');
        tx.textContent = `${giver} gifted ${count} ${tier} subs to the community!`;
        el.appendChild(tx);
        messageList.appendChild(el);
        messagesMap.set(d.messageId, el);
        scheduleHide(el);
      }

      function handleRewardRedemption(d) {
        if (d.reward.cost < minRewardCost) return;
        const actual = d.user_name.toLowerCase() !== (d.user_login || '').toLowerCase()
          ? `${d.user_name} (${(d.user_login || '').toLowerCase()})`
          : d.user_name;
        const el = createSubscriptionElement('REWARD REDEMPTION', '#64d419', 'mdi:star-four-points-circle-outline');
        el.dataset.msgId = d.id;
        const tx = document.createElement('div');
        tx.classList.add('subscription-text');
        tx.textContent = `${actual} redeemed ${d.reward.title} for ${d.reward.cost} channel points!`;
        if (d.user_input && d.user_input.trim()) {
          tx.appendChild(document.createElement('br'));
          tx.appendChild(document.createTextNode('↪  «' + d.user_input + '»'));
        }
        el.appendChild(tx);
        messageList.appendChild(el);
        messagesMap.set(d.id, el);
        scheduleHide(el);
      }

      function handleWatchStreak(d) {
        const actual = d.displayName.toLowerCase() !== d.userName.toLowerCase()
          ? `${d.displayName} (${d.userName.toLowerCase()})`
          : d.displayName;
        const el = createSubscriptionElement('WATCH STREAK', '#ff6b4a', 'lucide:flame');
        el.dataset.msgId = d.msgId;
        const tx = document.createElement('div');
        tx.classList.add('subscription-text');
        tx.textContent = `${actual} is on a ${d.watchStreak}x watch streak!`;
        if (d.message && d.message.trim()) {
          tx.appendChild(document.createElement('br'));
          tx.appendChild(document.createTextNode('↪  «' + d.message + '»'));
        }
        el.appendChild(tx);
        messageList.appendChild(el);
        messagesMap.set(d.msgId, el);
        scheduleHide(el);
      }

      function handleCheer(d) {
        const actual = d.user.name.toLowerCase() !== d.user.login.toLowerCase()
          ? `${d.user.name} (${d.user.login.toLowerCase()})`
          : d.user.name;
        const bits = d.bits;
        const cm = (d.message.message || '').replace(/Cheer\d+/gi, '').trim();
        const el = createSubscriptionElement('CHEER', '#FFD700', 'mingcute:diamond-square-line');
        el.dataset.msgId = d.messageId;
        const tx = document.createElement('div');
        tx.classList.add('subscription-text');
        tx.textContent = `${actual} cheered with ${bits} bits!`;
        if (cm) {
          tx.appendChild(document.createElement('br'));
          tx.appendChild(document.createTextNode('↪  «' + cm + '»'));
        }
        el.appendChild(tx);
        messageList.appendChild(el);
        messagesMap.set(d.messageId, el);
        scheduleHide(el);
      }

      function handleRaid(d) {
        const name = d.from_broadcaster_user_name;
        const login = d.from_broadcaster_user_login.toLowerCase();
        const actual = name.toLowerCase() !== login ? `${name} (${login})` : name;
        const id = d.messageId || Math.random().toString(36);
        const el = createSubscriptionElement('RAID', '#10e094', 'lsicon:user-crowd-outline');
        el.dataset.msgId = id;
        const tx = document.createElement('div');
        tx.classList.add('subscription-text');
        tx.textContent = `${actual} raided with ${d.viewers} viewers!`;
        el.appendChild(tx);
        messageList.appendChild(el);
        messagesMap.set(id, el);
        scheduleHide(el);
      }

      function handleDonation(d) {
        const df = d.isPublic ? d.from : 'Someone';
        const el = createSubscriptionElement('DONATION', '#26acff', 'hugeicons:money-03');
        el.dataset.msgId = d.messageId;
        const tx = document.createElement('div');
        tx.classList.add('subscription-text');
        tx.textContent = `${df} donated ${d.currency} ${d.amount}`;
        if (d.message && d.message.trim()) {
          tx.appendChild(document.createElement('br'));
          tx.appendChild(document.createTextNode('↪  «' + d.message + '»'));
        }
        el.appendChild(tx);
        messageList.appendChild(el);
        messagesMap.set(d.messageId, el);
        scheduleHide(el);
      }

      function deleteChatMessage(msgId) {
        const el = messagesMap.get(msgId);
        if (el) {
          messageList.removeChild(el);
          messagesMap.delete(msgId);
          msgEmotesMap.delete(msgId);
          replyPreviewsMap.delete(msgId);
          userMessagesMap.forEach((set, uid) => {
            set.delete(msgId);
            if (!set.size) userMessagesMap.delete(uid);
          });
        }
      }

      function removeUserMessages(uid) {
        if (!userMessagesMap.has(uid)) return;
        Array.from(userMessagesMap.get(uid)).forEach(id => removeMessageById(id));
        userMessagesMap.delete(uid);
      }

      function removeMessageById(msgId) {
        const el = messagesMap.get(msgId);
        if (el) {
          messageList.removeChild(el);
          messagesMap.delete(msgId);
          msgEmotesMap.delete(msgId);
          replyPreviewsMap.delete(msgId);
          userMessagesMap.forEach((set, uid) => {
            set.delete(msgId);
            if (!set.size) userMessagesMap.delete(uid);
          });
        }
      }

      function clearAllMessages() {
        messageList.innerHTML = '';
        messagesMap.clear();
        userMessagesMap.clear();
        replyPreviewsMap.clear();
        msgEmotesMap.clear();
        offset = 0;
        messageList.style.transition = 'none';
        messageList.style.transform = 'translateY(0)';
      }

      function escapeRegExp(s) {
        return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }

      function replaceEmotesInText(text, emotes) {
        if (!emotes || !emotes.length) return document.createTextNode(text);
        const frag = document.createDocumentFragment();
        let idx = 0;
        emotes.sort((a, b) => a.startIndex - b.startIndex).forEach(e => {
          if (idx < e.startIndex) frag.appendChild(document.createTextNode(text.slice(idx, e.startIndex)));
          const img = document.createElement('img');
          img.src = e.imageUrl;
          img.alt = e.name;
          img.classList.add('emote');
          frag.appendChild(img);
          idx = e.endIndex + 1;
        });
        if (idx < text.length) frag.appendChild(document.createTextNode(text.slice(idx)));
        return frag;
      }

      function createSubscriptionElement(title, color, icon) {
        const el = document.createElement('div');
        el.classList.add('subscription');
        const hd = document.createElement('div');
        hd.classList.add('subscription-header');
        if (!hideIcons) {
          const ic = document.createElement('div');
          ic.classList.add('icon');
          ic.innerHTML = `<span class="iconify" data-icon="${icon}" data-inline="false"></span>`;
          hd.appendChild(ic);
        }
        const tt = document.createElement('span');
        tt.classList.add('subscription-title');
        tt.textContent = title;
        tt.style.color = color;
        hd.appendChild(tt);
        if (!hideTimestamp) {
          const ts = document.createElement('span');
          ts.classList.add('pronouns-box');
          ts.textContent = new Date().toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
          hd.appendChild(ts);
        }
        el.appendChild(hd);
        return el;
      }

      function scheduleHide(el) {
        if (!hideAfterSeconds) return;
        setTimeout(() => {
          el.classList.add('fade-out');
          setTimeout(() => el.remove(), 500);
        }, hideAfterSeconds * 1000);
      }


      const client = new StreamerbotClient({
        host: address,
        port: Number(port),
        onConnect: () => {
          statusIndicator.textContent = 'CONNECTED';
          statusIndicator.style.background = 'green';
          setTimeout(() => statusIndicator.classList.add('hidden'), 2000);
        },
        onDisconnect: () => {
          statusIndicator.textContent = 'DISCONNECTED';
          statusIndicator.style.background = 'red';
          statusIndicator.classList.remove('hidden');
        },
        onError: err => console.error('Streamer.bot Client Error', err)
      });

      client.on('Twitch.ChatMessage', evt => {
        const d = evt.data || evt;
        const type = 'chatmessage';
        if (excludeEventsParam.includes(type)) return;
        addChatMessage(d.message, d.user, d.emotes, d.isSharedChat, d.sharedChat);
      });

      client.on('Twitch.ChatMessageDeleted', (evt) => {
        const data = evt.data || evt;
        const type = 'chatmessagedeleted';
        if (excludeEventsParam.includes(type)) return;
        deleteChatMessage(data.messageId);
      });
      client.on('Twitch.UserTimedOut', (evt) => {
        const data = evt.data || evt;
        const type = 'usertimedout';
        if (excludeEventsParam.includes(type)) return;
        removeUserMessages(data.user_id);
      });
      client.on('Twitch.UserBanned', (evt) => {
        const data = evt.data || evt;
        const type = 'userbanned';
        if (excludeEventsParam.includes(type)) return;
        removeUserMessages(data.user_id);
      });
      client.on('Twitch.ChatCleared', (evt) => {
        const data = evt.data || evt;
        const type = 'chatcleared';
        if (excludeEventsParam.includes(type)) return;
        clearAllMessages();
      });
      client.on('Twitch.AutomaticRewardRedemption', (evt) => {
        const data = evt.data || evt;
        const type = 'automaticrewardredemption';
        if (excludeEventsParam.includes(type)) return;
        handleAutomaticRewardRedemption(data);
      });
      client.on('Twitch.Announcement', (evt) => {
        const data = evt.data || evt;
        const type = 'announcement';
        if (excludeEventsParam.includes(type)) return;
        handleAnnouncement(data);
      });
      client.on('Twitch.Sub', (evt) => {
        const data = evt.data || evt;
        const type = 'sub';
        if (excludeEventsParam.includes(type)) return;
        handleSubscription(data);
      });
      client.on('Twitch.ReSub', (evt) => {
        const data = evt.data || evt;
        const type = 'resub';
        if (excludeEventsParam.includes(type)) return;
        handleReSubscription(data);
      });
      client.on('Twitch.GiftSub', (evt) => {
        const data = evt.data || evt;
        const type = 'giftsub';
        if (excludeEventsParam.includes(type)) return;
        handleGiftSubscription(data);
      });
      client.on('Twitch.GiftBomb', (evt) => {
        const data = evt.data || evt;
        const type = 'giftbomb';
        if (excludeEventsParam.includes(type)) return;
        handleGiftBombSubscription(data);
      });
      client.on('Twitch.RewardRedemption', (evt) => {
        const data = evt.data || evt;
        const type = 'rewardredemption';
        if (excludeEventsParam.includes(type)) return;
        handleRewardRedemption(data);
      });
      client.on('Twitch.WatchStreak', (evt) => {
        const data = evt.data || evt;
        const type = 'watchstreak';
        if (excludeEventsParam.includes(type)) return;
        handleWatchStreak(data);
      });
      client.on('Twitch.Cheer', (evt) => {
        const data = evt.data || evt;
        const type = 'cheer';
        if (excludeEventsParam.includes(type)) return;
        handleCheer(data);
      });
      client.on('Twitch.Raid', (evt) => {
        const data = evt.data || evt;
        const type = 'raid';
        if (excludeEventsParam.includes(type)) return;
        handleRaid(data);
      });
      client.on('Kofi.Donation', (evt) => {
        const data = evt.data || evt;
        const type = 'donation';
        if (excludeEventsParam.includes(type)) return;
        handleDonation(data);
      });
    })();
  </script>
</body>

</html>
