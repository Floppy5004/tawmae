<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>VERTICAL CHAT - v.1.0.6 - tawmae</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800;900&display=swap" rel="stylesheet">
  <script src="https://code.iconify.design/2/2.2.1/iconify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
      font-family: 'Poppins', sans-serif;
      font-size: 16px;
      color: #ffffff;
      text-shadow: none;
    }

    body.dropshadow * {
      text-shadow: 1.3px 1.3px 1.3px black;
    }

    body.big-dropshadow * {
      text-shadow: 0.8px 0.8px black, 0.9px 0.9px black, 1px 1px black, 1.1px 1.1px black, 1.2px 1.2px black, 1.3px 1.3px black, 1.4px 1.4px black, 1.5px 1.5px black;
    }

    body.dropshadow .iconify,
    body.big-dropshadow .iconify {
      filter: drop-shadow(1.3px 1.3px 1.3px black);
    }

    body.big-dropshadow .iconify {
      filter: drop-shadow(0.8px 0.8px black, 0.9px 0.9px black, 1px 1px black, 1.1px 1.1px black, 1.2px 1.2px black, 1.3px 1.3px black, 1.4px 1.4px black, 1.5px 1.5px black);
    }

    #background-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    #chat-container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: transparent;
      z-index: 1;
    }

    #messages {
      flex: 1;
      padding: 0.625em;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    #message-list {
      display: flex;
      flex-direction: column;
      position: relative;
      transform: translateY(0);
      will-change: transform;
    }

    .message,
    .announcement,
    .subscription {
      margin-bottom: 0.625em;
      display: flex;
      flex-direction: column;
      opacity: 0;
      transform: translateY(100%);
      animation: slide-in-up 0.5s forwards;
      color: #ffffff;
    }

    @keyframes slide-in-up {
      from {
        opacity: 0;
        transform: translateY(100%);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .fade-out {
      animation: fade-out 0.5s forwards;
    }

    @keyframes fade-out {
      from {
        opacity: 1;
        transform: translateY(0);
      }

      to {
        opacity: 0;
        transform: translateY(-20px);
      }
    }

    .message-header,
    .announcement-header,
    .subscription-header {
      display: flex;
      align-items: center;
      margin-bottom: 0.3125em;
    }

    .avatar {
      height: 2.5em;
      width: 2.5em;
      border-radius: 50%;
      margin-right: 0.3125em;
      flex-shrink: 0;
    }

    .shared-chat-icon {
      height: 1em;
      width: 1em;
      border-radius: 50%;
      margin-left: 0.3125em;
    }

    .badges img {
      height: 1em;
      width: 1em;
      margin-right: 0.125em;
      margin-top: 0.375em;
    }

    .username {
      font-weight: 700;
      margin-right: 0.3125em;
      margin-left: 0.3125em;
      display: inline-flex;
      align-items: center;
    }

    .pronouns-box {
      font-size: 0.625em;
      color: #cccccc;
      background: #333333;
      padding: 0 0.1875em;
      border-radius: 0.1875em;
      margin-left: 0.3125em;
      display: inline-flex;
      align-items: center;
    }

    .new-chatter {
      font-size: 0.75em;
      color: #00FFFF;
      font-weight: 600;
      margin-left: 0.3125em;
      display: inline-flex;
      align-items: center;
    }

    .message-text {
      word-wrap: break-word;
      margin: 0.0625em 0 0.3125em 0;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      width: 100%;
      margin-top: 0;
    }

    .announcement-text,
    .subscription-text {
      word-wrap: break-word;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      width: 100%;
      margin-top: 0;
    }

    .message-text img,
    .announcement-text img,
    .subscription-text img {
      height: 1.25em;
      width: auto;
      object-fit: contain;
      vertical-align: middle;
      margin-left: 0.25em;
      margin-right: 0.25em;
    }

    .gigantified-emote {
      width: 6.25em !important;
      height: 6.25em !important;
      object-fit: contain;
      vertical-align: middle;
      margin-left: 0.25em;
      margin-right: 0.25em;
    }

    .reply-preview {
      padding: 0.0625em 0.1875em;
      margin: 0.0625em 0 0.3125em 0;
      font-size: 0.75em;
      color: #dddddd;
      max-width: 100%;
      word-wrap: break-word;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-style: italic;
      display: flex;
      align-items: center;
    }

    .reply-preview img {
      height: 0.75em;
      width: auto;
      object-fit: contain;
      vertical-align: middle;
      margin-left: 0.125em;
      margin-right: 0.125em;
    }

    .announcement .icon,
    .subscription .icon {
      height: 1em;
      width: 1em;
      margin-right: 0.3125em;
      flex-shrink: 0;
      margin-bottom: 0.3125em;
    }

    .announcement .icon svg,
    .subscription .icon svg {
      width: 100%;
      height: 100%;
      fill: currentColor;
    }

    .announcement-title,
    .subscription-title {
      font-weight: 900;
      font-size: 1em;
    }

    #status-indicator {
      position: fixed;
      top: 0.625em;
      right: 0.625em;
      background: red;
      color: #fff;
      padding: 0.3125em 0.625em;
      border-radius: 0.25em;
      font-size: 0.875em;
      z-index: 9999;
      transition: background 0.5s, opacity 0.5s;
    }

    .hidden {
      opacity: 0;
      pointer-events: none;
    }

    .message-text img:not(.gigantified-emote),
    .announcement-text img:not(.gigantified-emote),
    .subscription-text img:not(.gigantified-emote) {
      height: 1.8em;
    }
  </style>
</head>

<body>
  <div id="status-indicator">DISCONNECTED</div>
  <div id="chat-container">
    <div id="messages">
      <div id="message-list"></div>
    </div>
  </div>
  <script>
    (function () {
      const MAX_CACHE_SIZE = 1000;
      function cacheSet(map, key, value) {
        if (map.size >= MAX_CACHE_SIZE) {
          map.delete(map.keys().next().value);
        }
        map.set(key, value);
      }
      const params = new URLSearchParams(window.location.search);
      const caseInsensitiveParams = {};
      for (const [key, value] of params.entries()) {
        caseInsensitiveParams[key.toLowerCase()] = value;
      }
      function getParam(key, defaultValue = null) {
        return caseInsensitiveParams[key.toLowerCase()] || defaultValue;
      }
      const font = getParam('font', 'Poppins');
      const fontsize = getParam('fontsize', '16px');
      const dropshadow = getParam('dropshadow', 'true') !== 'false';
      const excludedAccounts = getParam('excludeaccounts', '')
        .split(/[,+\s]+/)
        .map(acc => acc.trim().toLowerCase())
        .filter(acc => acc);
      const excludeCommands = getParam('excludecommands', 'false') === 'true';
      const enterDirection = getParam('enter', 'right') === 'left' ? 'left' : 'right';
      const excludeEventsParam = getParam('excludeevents', '')
        .split(/[,+\s]+/)
        .map(e => e.trim().toLowerCase())
        .filter(e => e);
      const address = getParam('address', '127.0.0.1');
      const port = getParam('port', '8080');
      const backgroundEnabled = getParam('background', 'false') === 'true';
      const backgroundOpacity = getParam('backgroundopacity', '90');
      const backgroundColor = getParam('backgroundcolor', 'black');
      const showPronouns = getParam('showpronouns', 'true') !== 'false';
      const showTimestamp = getParam('showtimestamp', 'false') === 'true';
      const showAvatars = getParam('showavatars', 'true') !== 'false';
      const minRewardCost = parseInt(getParam('minrewardcost', '0'), 10);
      const hideAfterSeconds = parseInt(getParam('hideafter', '0'), 10) || null;
      const justify = getParam('justify', '');
      const forceUpper = getParam('forceuppercase', 'false') === 'true';
      const forceLower = getParam('forcelowercase', 'false') === 'true';
      const hideIcons = getParam('hideicons', 'false') === 'true';
      const hideBadges = getParam('hidebadges', 'false') === 'true';
      const bigDropshadow = getParam('bigdropshadow', 'false') === 'true';
      const backgroundStyle = (getParam('backgroundstyle') || '').toLowerCase();

      document.body.style.fontFamily = `${font}, sans-serif`;
      document.body.style.fontSize = fontsize;
      if (dropshadow) {
        document.body.classList.add(bigDropshadow ? 'big-dropshadow' : 'dropshadow');
      }
      document.body.style.backgroundColor = 'transparent';
      if (forceUpper) {
        document.body.style.textTransform = 'uppercase';
      } else if (forceLower) {
        document.body.style.textTransform = 'lowercase';
      }

      const chatContainer = document.getElementById('chat-container');
      const messagesContainer = document.getElementById('messages');
      const messageList = document.getElementById('message-list');
      const statusIndicator = document.getElementById('status-indicator');

      chatContainer.style.position = 'absolute';
      chatContainer.style.top = '0';
      if (enterDirection === 'left') {
        chatContainer.style.left = '0';
        chatContainer.style.right = 'auto';
      } else {
        chatContainer.style.right = '0';
        chatContainer.style.left = 'auto';
      }

      if (justify === 'right') {
        chatContainer.style.textAlign = 'right';
        messageList.style.alignItems = 'flex-end';
        const styleEl = document.createElement('style');
        styleEl.innerHTML =
          ".message, .announcement, .subscription { text-align: right; }" +
          ".message-header, .announcement-header, .subscription-header { justify-content: flex-end; }" +
          ".message-text, .announcement-text, .subscription-text { text-align: right; }";
        document.head.appendChild(styleEl);
      } else if (justify === 'left') {
        chatContainer.style.textAlign = 'left';
        messageList.style.alignItems = 'flex-start';
      }

      function parseColorToRGBA(col, alpha) {
        const temp = document.createElement('div');
        temp.style.color = col;
        document.body.appendChild(temp);
        const computed = window.getComputedStyle(temp).color;
        document.body.removeChild(temp);
        if (computed.startsWith('rgba')) {
          return computed.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*(.*)\)/, `rgba($1,$2,$3,${alpha})`);
        } else if (computed.startsWith('rgb')) {
          return computed.replace(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/, `rgba($1,$2,$3,${alpha})`);
        }
        return col;
      }

      if (backgroundEnabled && ['cards', 'cardsrounded'].includes(backgroundStyle)) {
        const op = Number(backgroundOpacity) / 100;
        const rgba = parseColorToRGBA(backgroundColor, op);
        const styleEl = document.createElement('style');
        styleEl.innerHTML = `
          .message, .announcement, .subscription {
            background-color: ${rgba} !important;
            padding: 0.5em;
            margin: 0.5em 0;
          }
        `;
        if (backgroundStyle === 'cardsrounded') {
          styleEl.innerHTML += `
            .message, .announcement, .subscription {
              border-radius: 0.5em;
            }
          `;
        }
        document.head.appendChild(styleEl);
      } else if (backgroundEnabled) {
        const overlay = document.createElement('div');
        overlay.id = 'background-overlay';
        overlay.style.backgroundColor = backgroundColor;
        overlay.style.opacity = Number(backgroundOpacity) / 100;
        document.body.insertBefore(overlay, document.body.firstChild);
      }

      const messagesMap = new Map();
      const userMessagesMap = new Map();
      const avatarCache = new Map();
      const sharedChatAvatarCache = new Map();
      const replyPreviewsMap = new Map();
      const msgEmotesMap = new Map();
      const userColorCache = new Map();
      const pronounCache = new Map();
      const pendingGigantify = new Map();

      let offset = 0;
      let animating = false;
      let eventQueue = Promise.resolve();
      let eventQueueCount = 0;

      function processEvent(fn) {
        return new Promise(resolve => {
          fn();
          adjustOffset().then(resolve);
        });
      }

      function adjustOffset() {
        return new Promise(resolve => {
          const containerH = messagesContainer.clientHeight;
          const contentH = messageList.scrollHeight;
          const desired = Math.max(0, contentH - containerH);
          if (desired === offset) return resolve();
          animateOffsetChange(offset, desired).then(() => {
            offset = desired;
            resolve();
          });
        });
      }

      function animateOffsetChange(from, to) {
        return new Promise(resolve => {
          if (document.hidden) {
            messageList.style.transition = 'none';
            messageList.style.transform = `translateY(-${to}px)`;
            return resolve();
          }
          if (animating) {
            return requestAnimationFrame(() => {
              animateOffsetChange(from, to).then(resolve);
            });
          }
          animating = true;
          const duration = eventQueueCount > 3 ? 0.1 : 0.5;
          messageList.style.transition = `transform ${duration}s ease`;
          messageList.addEventListener('transitionend', onEnd);
          requestAnimationFrame(() => {
            messageList.style.transform = `translateY(-${to}px)`;
          });
          function onEnd() {
            messageList.removeEventListener('transitionend', onEnd);
            animating = false;
            resolve();
          }
        });
      }

      async function getPronouns(login) {
        if (pronounCache.has(login)) return pronounCache.get(login);
        try {
          const resp = await client.getUserPronouns('twitch', login);
          if (resp.status === 'ok' && resp.pronoun?.userFound) {
            const p = resp.pronoun.pronouns.replace(/^\(|\)$/g, '');
            pronounCache.set(login, p);
            return p;
          }
        } catch { }
        pronounCache.set(login, null);
        return null;
      }

      function updateExistingGigantify(key, emote) {
        userMessagesMap.forEach((ids, uid) => {
          ids.forEach(id => {
            const el = messagesMap.get(id);
            if (el && el.dataset.userName === key.split('|')[0].toLowerCase() && el.dataset.raw === key.split('|')[1]) {
              el.querySelectorAll('img').forEach(img => {
                if (img.alt === emote.name) img.classList.add('gigantified-emote');
              });
            }
          });
        });
      }

      function addChatMessage(m, u, e, isShared, sharedData) {
        const { msgId, displayName, color, badges, message, parts, isReply, reply, firstMessage } = m;
        const user = (u.username || u.login || u.name || '').toLowerCase();
        if (!user || excludedAccounts.includes(user)) return;

        if (excludeCommands && message.startsWith('!')) return;

        const el = document.createElement('div');
        el.classList.add('message');
        el.dataset.msgId = msgId;
        el.dataset.raw = message;
        el.dataset.userName = user;

        const header = document.createElement('div');
        header.classList.add('message-header');

        if (showAvatars) {
          const avatar = document.createElement('img');
          avatar.classList.add('avatar');
          if (avatarCache.has(user)) {
            avatar.src = avatarCache.get(user);
          } else {
            fetch(`https://decapi.me/twitch/avatar/${user}`)
              .then(r => r.text())
              .then(u => { avatar.src = u; cacheSet(avatarCache, user, u); })
              .catch(() => avatar.src = '');
          }
          header.appendChild(avatar);
        }

        if (!hideBadges && Array.isArray(badges)) {
          const bc = document.createElement('div');
          bc.classList.add('badges');
          badges.forEach(b => {
            const bi = document.createElement('img');
            bi.src = b.imageUrl;
            bi.alt = b.name;
            bc.appendChild(bi);
          });
          header.appendChild(bc);
        }

        const uname = document.createElement('span');
        uname.classList.add('username');
        uname.textContent = displayName;
        uname.style.color = color || '#fff';
        header.appendChild(uname);

        if (showPronouns || showTimestamp) {
          if (showPronouns) {
            getPronouns(user).then(p => {
              if (p) {
                const pn = document.createElement('span');
                pn.classList.add('pronouns-box');
                pn.textContent = p;
                header.appendChild(pn);
              }
              if (showTimestamp) {
                const ts = document.createElement('span');
                ts.classList.add('pronouns-box');
                ts.textContent = new Date().toLocaleTimeString(navigator.language, { hour: '2-digit', minute: '2-digit' });
                header.appendChild(ts);
              }
            });
          } else {
            const ts = document.createElement('span');
            ts.classList.add('pronouns-box');
            ts.textContent = new Date().toLocaleTimeString(navigator.language, { hour: '2-digit', minute: '2-digit' });
            header.appendChild(ts);
          }
        }

        el.appendChild(header);

        if (color) userColorCache.set(u.userId, color);

        const textContainer = document.createElement('div');
        textContainer.classList.add('message-text');

        if (Array.isArray(parts)) {
          parts.forEach(pt => {
            if (pt.type === 'text') {
              textContainer.appendChild(document.createTextNode(pt.text));
            } else {
              const img = document.createElement('img');
              img.src = pt.imageUrl;
              img.alt = pt.text;
              textContainer.appendChild(img);
            }
          });
        } else {
          let txt = message || '';
          let last = 0;
          (e || []).sort((a, b) => a.startIndex - b.startIndex).forEach(emote => {
            if (emote.startIndex > last) {
              textContainer.appendChild(document.createTextNode(txt.slice(last, emote.startIndex)));
            }
            const img = document.createElement('img');
            img.src = emote.imageUrl;
            img.alt = emote.name;
            textContainer.appendChild(img);
            last = emote.endIndex + 1;
          });
          if (last < txt.length) {
            textContainer.appendChild(document.createTextNode(txt.slice(last)));
          }
        }

        el.appendChild(textContainer);
        messageList.appendChild(el);
        messagesMap.set(msgId, el);

        scheduleHide(el);
      }

      function scheduleHide(el) {
        if (!hideAfterSeconds) return;
        setTimeout(() => {
          el.classList.add('fade-out');
          el.addEventListener('animationend', () => {
            if (el.parentNode) el.parentNode.removeChild(el);
            adjustOffset();
          }, { once: true });
        }, hideAfterSeconds * 1000);
      }

      const client = new StreamerbotClient({
        host: address,
        port: Number(port),
        onConnect: () => {
          statusIndicator.textContent = 'CONNECTED';
          statusIndicator.style.background = 'green';
          setTimeout(() => statusIndicator.classList.add('hidden'), 2000);
        },
        onDisconnect: () => {
          statusIndicator.textContent = 'DISCONNECTED';
          statusIndicator.style.background = 'red';
          statusIndicator.classList.remove('hidden');
        },
        onError: err => console.error('Streamer.bot Client Error', err)
      });

      client.on('Twitch.ChatMessage', async evt => {
        const d = evt.data || evt;
        const type = 'chatmessage';
        if (!excludeEventsParam.includes(type)) {
          eventQueueCount++;
          eventQueue = eventQueue
            .then(() => processEvent(() => addChatMessage(d.message, d.user, d.emotes, d.isSharedChat, d.sharedChat)))
            .finally(() => eventQueueCount--);
        }
      });
      client.on('Twitch.ChatMessageDeleted', async (evt) => {
        const data = evt.data || evt;
        const type = 'chatmessagedeleted';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => deleteChatMessage(data.messageId));
      });
      client.on('Twitch.UserTimedOut', async (evt) => {
        const data = evt.data || evt;
        const type = 'usertimedout';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => removeUserMessages(data.user_id));
      });
      client.on('Twitch.UserBanned', async (evt) => {
        const data = evt.data || evt;
        const type = 'userbanned';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => removeUserMessages(data.user_id));
      });
      client.on('Twitch.ChatCleared', async (evt) => {
        const data = evt.data || evt;
        const type = 'chatcleared';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => clearAllMessages());
      });
      client.on('Twitch.AutomaticRewardRedemption', async (evt) => {
        const data = evt.data || evt;
        const type = 'automaticrewardredemption';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => handleAutomaticRewardRedemption(data));
      });
      client.on('Twitch.Announcement', async (evt) => {
        const data = evt.data || evt;
        const type = 'announcement';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => handleAnnouncement(data));
      });
      client.on('Twitch.Sub', async (evt) => {
        const data = evt.data || evt;
        const type = 'sub';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => handleSubscription(data));
      });
      client.on('Twitch.ReSub', async (evt) => {
        const data = evt.data || evt;
        const type = 'resub';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => handleReSubscription(data));
      });
      client.on('Twitch.GiftSub', async (evt) => {
        const data = evt.data || evt;
        const type = 'giftsub';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => handleGiftSubscription(data));
      });
      client.on('Twitch.GiftBomb', async (evt) => {
        const data = evt.data || evt;
        const type = 'giftbomb';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => handleGiftBombSubscription(data));
      });
      client.on('Twitch.RewardRedemption', async (evt) => {
        const data = evt.data || evt;
        const type = 'rewardredemption';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => handleRewardRedemption(data));
      });
      client.on('Twitch.WatchStreak', async (evt) => {
        const data = evt.data || evt;
        const type = 'watchstreak';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => handleWatchStreak(data));
      });
      client.on('Twitch.Cheer', async (evt) => {
        const data = evt.data || evt;
        const type = 'cheer';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => handleCheer(data));
      });
      client.on('Twitch.Raid', async (evt) => {
        const data = evt.data || evt;
        const type = 'raid';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => handleRaid(data));
      });
      client.on('Kofi.Donation', async (evt) => {
        const data = evt.data || evt;
        const type = 'donation';
        if (excludeEventsParam.includes(type)) return;
        await processEvent(() => handleDonation(data));
      });
    })();
  </script>
</body>

</html>
